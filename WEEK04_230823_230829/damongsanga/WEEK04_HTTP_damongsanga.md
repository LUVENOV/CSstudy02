## 2.5 HTTP

: 애플리케이션 계층으로서 웹서비스 통신에 사용

### 2.5.1 HTTP/1.0

: 한 연결당 하나의 요청을 처리

- 문제 : RTT 증가

  - RTT : 패킷 왕복시간, 패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기 까지 걸리는 시간
  - 서버로부터 파일을 가져올 떄마다 TCP의 3-way handshake를 계속해서 열어야 하는 문제

- RTT 개선 방법

  - 매번 연결할 때마다 RTT가 증가하니 서버 부담 및 사용자 응답시간 길어짐

    ##### 이미지 스플리팅

    - 이미지를 다량 다운받을 때 다수의 이미지보다 많은 이미지가 합쳐져 있는 하나의 이미지를 다운로드
    - 이를 기반으로 background-image의 position 이용하여 이미지 표기하는 방법

    ```
    #icons>li>a {
        background-image: url("icons.png");
        width: 25px;
        display: inline-block;
        height: 25px;
        repeat: no-repeat;
    }

    #icons>li:nth-child(1)>a {
        background-position: 2px -8px;
    }
    #icons>li:nth-child(2)>a {
        background-position: -29px -8px;
    }
    ```

    ##### 코드 압축

    - 개행문자, 빈칸을 없애서 코드 크기 최소화
    - 압축 전

    ```
    const express = require('express')
    const app = express()
    const port = 3000
    app.get('/', (req, res) => {
        res.send('Hello World!')
    })
    app.listen(port, () => {
        console.log(`Example app listening on port ${port}`)
    })
    ```

    - 압축 후

    ```
    const express=require("express"),app=express(),port=3e3;app.get("/",(e,p)=>{p.send("Hello World!")}),app.listen(3e3,()=>{console.log("Example app listening on port 3000")});
    ```

    #### 이미지 Base64 인코딩

    - 이미지 파일을 64진법으로 이루어진 문자열로 인코딩하는 방법 (6bit씩 끊어서 처리하는 방식)
    - 서버와의 연결을 열고 이미지에 대해 서버에 HTTP 요청을 할 필요가 없음 (요청 X)
    - 하지만, 이 경우 크기가 37% 정도 더 커짐
    - 인코딩 : 정보의 형태나 형식을 표준화, 보안, 처리속도 향상, 저장공간 절약 등을 위해 다른 형태나 형식으로 변환하는 처리 방식
      <br>
    - 예시 (EASY!)
      원본 데이터 CHS
      C : 0x43 > 0b01000011
      H : 0x48 > 0b01001000
      S : 0x53 > 0b01010011
      이어서 붙인 후 6개 비트 단위로 나눈다
      010000 110100 100001 010011
      Q 0 h T
      <br>
    - 왜?
      Binary bit stream data를 무조건 영문자로 변환하려 하는 성질 때문
      이는 html이 문서이며 이는 모두 ASCII Code로 표현
      그런데 ASCII code로 표현할 수 있는 binary data 가 존재할 수 있음 (대표적으로 이미지)
      이를 강제로 문자로 변형해서 문서 속에 이미지를 표현하고자 함
      어떠한 사용자가 문서를 보고 싶은데 HTML(10kb)만 보내는 경우와 HTML(1kb) + IMAGE(6kb)를 요청하는 경우 어느게 더 유리한가?
      용량면으로는 후자가 유리해보일 수 있지만 연결측면에서는 전자가 유리하다! (연결을 1번만 하면 됨)
      <br>
    - 6bit씩 끊다보니 원본이 애매하게 짜투리가 남으면?
      쓰레기 데이터인 패딩(=)을 넣어 강제로 6bit로 늘린다. 거꾸로 디코딩을 할 때는 패딩값을 버리면 된다!
    - 예시
      - "CHS" : Q0hT
      - "CHS " : Q0hTIA==

### 2.5.2 HTTP/1.1

- 매번 TCP 연결하는 것이 아닌 한번 TCP 초기화 후에 keep-alive 라는 옵션으로 여러 개의 파일을 송수신할 수 있도록 있게 변경됨
- 여기서 keep-alive는 HTTP/1.1 부터 기본 옵션으로 설정됨

#### Persistent Connection

- 지정한 time동안 커넥션을 닫지 않는 방식

#### 파이프라이닝 (Piplining)

- 실제 웹 요청에서는 순차적으로 진행되어야 하는 경우가 많음
- 때문에 먼저 처리해야하는 요청이 완료된 후에 다음 요청을 보내면 손해
- 해결방법 : 하나의 커넥션에서 응답을 기다리지 않고 순차적인 여러 요청을 연속적으로 보냄
- 그 순서에 맞춰 응답을 받아 지연 시간을 줄이는 방식
  <br>

#### 주요 단점

#### 1. HTTP의 HOL Blocking (Head Of Line Blocking)

- 파이프라이닝의 문제!
- 우선순위가 높은 요청이 처리되지 않을 때 다음 요청이 처리되지 않는 문제
- 네트워크에서 같은 큐에 있는 패킷이 그 첫 번째 패킷에 의해 지연될 때 발생하는 성능 저하
- 예를 들어 image.jpg, style.css, data.xml을 다운로드 받을 때 보통은 순차적으로 받아지나 image.jpg가 느리게 받아지면 그 뒤 자료들이 대기하게 됨
- 문서에 포함된 다수의 리소스 (이미지, css 파일, script 파일) 을 처리하려면 요청할 리소스 개수에 비례해서 대기 시간이 길어질 확률이 높아짐

#### 2. 무거운 헤더 구조

- HTTP/1.1 헤더에는 쿠키 등 많은 메타데이터가 들어있어 압축이 되지 않아 무거움
- 특히 연속된 요청의 경우 header에 중복내용이 많음

#### 3. 효율적인 리소스 우선 순위를 지정을 허용치 않으므로써 생길 수 있는 TCP 연결 문제

### 2.5.3 HTTP/2

- 기존 HTTP/1.x 버전의 성능 향상에 초점을 맞춘 프로토콜
- 표준 "대체"가 아닌 "확장"
- SPDY 프토콜에서 파생된 HTTP/1.x보다 지연시간을 줄이고 응답 시간을 더 빠르게 함
- 모든 HTTP/2 연결은 영구적이고 출처당 하나의 연결만 필요하게 된다! (아래 참고)

#### HTTP 메시지 전송 방식 변경 (바이너리 프레이밍)

- HTTP 1.1 : 평문 (plane text) 사용
- HTTP 2.0 : 바이너리 프레이밍 계층
  - 스트림 : 구성 된 연결 내에서 전달되는 바이트는 양방향의 흐름, 하나 이상의 메세지 전달이 가능
  - 메세지 : 논리적 요청 또는 응답 메세지에 매칭되는 프레임의 전체 시퀀스 (집합)
  - 프레임 : HTTP 에서 통신의 최소 단위로 각각의 단위에는 하나의 프레임 헤더가 포함
    - 프레임 헤더 : 최소한으로 어떤 스트림에 속하는 프레임인지 식별을 가능하게 함
- 파싱, 전송속도 증가, 오류발생 가능성 감소

#### 멀티 플렉싱 (HOL Blocking 해결)

- 여러개의 스트림을 송수신 (HTTP의 HOL Blocking 해결)
  - 그러나 스트림 개별의 HOL Blocking은 해결할 수 없음 (TCP의 고질적인 문제)
- 요청을 프레임 단위로 쪼개서 송수신
- 기존 HTTP/1.x에서 클라이언트가 병렬 요청을 요청하는 경우 여러개의 TCP 연결 필요
  - 연결당 한 번에 하나의 응답
  - 기본 TCP 연결의 비효율적 사용 초래
- HTTP/2 는 전체요청, 응답 다중화 지원
  - 여러 요청/응답 병렬 인터리빙 가능
  - 단일 연결만으로 여러 요청/응답 병렬 처리 가능
- 장점
  - 특정 스트림의 패킷이 손실되어도 해당 스트림에만 영향, 나머지 스트림은 정상 동작
  - 연결 수 감소 (1개면 됨)
  - 애플리케이션 단순화
  - 배포 비용 절감

#### 헤더 압축 ( > HPACK 압축 형식)

- HTTP/1.x의 경우 이 메타데이터는 항상 일반 텍스트로 전송되고, 전송당 500~800바이트의 오버헤드가 추가되며, HTTP 쿠키를 사용할 경우 수 KB가 추가되기도
- 허프만 코딩 압축 알고리즘 : 문자열을 문자 단위로 쪼개 빈도수를 세서 빈도가 높은 정보는 적은 비트수를 사용하여 표현, 빈도가 낮은 정보는 비트 수를 많이 사용해서 표현하여 전체 비트양을 줄이는 알고리즘

#### 서버 푸시

- HTTP/1.1 : 클라이언트가 서버에 요청해야 파일 다운로드 받을 수 있음
- HTTP/2 : 클라이언트 요청 없이 서버가 바로 리소스 푸시
- 예시로 클라이언트가 html 파일만 요청하면 서버는 html과 같이 필요한 css 파일까지 같이 푸시할 수 있음

#### 스트림 우선순위 지정 (Stream Prioirtization)

- HTTP 메시지가 다중화되면서 전달 순서 또한 중요한 고려사항이 됨
- HTTP/2 표준에서 각 스트림이 연관된 가중치와 종속성을 갖도록 허용
  - 각 스트림에 1 ~ 256 정수 가중치 부여 가능
  - 각 스트림에 다른 스트림에 대한 명시적 종속성 부여 가능

### 2.5.4 HTTPS

- HTTPS : 애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣은 신뢰할 수 있는 HTTP 요청
- HTTP/2는 HTTPS 위에서 동작

* 여기서 주의할 점은 HTTPS는 HTTP 자체를 암호화하는 것이 아닌 데이터인 HTTP Body를 암호화 하는 것으로, HTTP 헤더는 암호화 되지 않음
* SEO (Search Engine Optimization) : google은 HTTPS를 쓸수록 SEO 순위가 높을 것임을 강조

#### SSL / TLS

- SSL (Secure Socket Layer) / TLS (Transport Layer Security Protocol)
  - 전송 계층에서 보안을 제공하는 프로토콜
  - 클라이언트와 서버가 통신할 떄 SSL/TLS 를 통해 제 3자가 메시지를 도청하거나 변조하지 못하도록
  - 공격자가 서버인 척 하며 사용자 정보를 가로채는 네트워크 인터셉터 방지
  - SSL 1.0 > 2.0 > 3.0 > TLS 1.0 > 1.3
  - 보안 세션을 기반으로 데이터 암호화
    - 인증 메커니즘
    - 키 교환 메커니즘
    - 해싱 알고리즘

#### 보안 세션

- SSL/TLS : 핸드쉐이크를 통해 보안 세션을 생성하고 이를 기반으로 상태 정보등을 공유
- 세션 : 운영체제가 어떠한 사용자로부터 자신의 자산 이용을 허락하는 일정한 기간
- 보안 세션 : 보안이 시작되고 끝나는동안 유지되는 세션
  - 1-RTT 후 데이터 송수신 : 클라이언트와 서버 키 공유하고 이를 기반으로 인증, 인증 확인 등의 작업이 일어남
  * 과정
    1. 사이퍼슈트 전달 : 클라이언트에서 사이퍼 슈트를 서버에 전달하면 서버는 받은 사이퍼 슈트의 암호화 알고리즘 리스트를 제공할 수 있는지 확인
    2. 인증 메커니즘 : 이를 제공할 수 있으면 서버에서 클라이언트로 인증서을 보내는 인증 메커니즘 실행
    3. 해싱 : 이후 해싱 알고리즘으로 암호화덴 데이터 송수신

* 사이퍼 슈트
  - 프로토콜 + AEAD 사이퍼 모드 + 해싱 알고리즘 이 나열된 규약
  - TLS_AES_128_GCM_SHA256
  - TLS_AES_128_GCM_SHA384
  - TLS_CHACHA20_POLY1305_SHA256
  - TLS_AES_128_CCM_SHA256
  - TLS_AES_128_CCM_8_SHA256

#### 1. AEAD 사이퍼 모드

: (Authenricated Encrypton sith Associated Data)

- 데이터 암호화 알고리즘
  - AES_128_GCM : 128 비트 키를 사용하는 표준 블록 암호화 기술 + 병렬 계사네 용이한 암호화 알고리즘 GCM 결합된 알고리즘

#### 2. 인증 메커니즘

- CA (Certificate Authorities) 에서 발급된 인증서 기반으로 이루어짐
  - 신뢰성이 엄격하게 공인된 기업들만 가능하며 Comodo, Godaddy, GlobalSign, Amazon등이 있다
- CA에서 발급된 인증서는 클라이언트에게 공개키 제공하며 사용자가 접속한 서버가 신뢰할 수 있는 서버임을 보장
- 인증서는 서비스 정보, 공개키, 지문, 디지털 서명 등으로 이루어져있음

#### 2.1 인증서 발급 과정

1. 자신의 사이트 정보와 공개키를 CA에 제출
2. CA는 공개키를 해시한 값인 지문을 사용하는 CA의 비밀키를 기반으로 CA 인증서 발급
   [참고 영상](https://www.youtube.com/watch?v=wPdH7lJ8jf0)

- ##### 대칭/공개/개인키
  - 대칭키 : 동일한 키로 암호화/복호화
    - 암호화/복호화가 쉬움
    - 공개키가 노출되었을 때 데이터 노출 위험
  - 공개/개인키 : 공개키로 암호화, 개인키로 복호화를 함
  - 통신 과정 (대칭키를 공개키로 암호화)
    1. 클라이언트 접속 요청
    2. 서버는 클라이언트에게 공개키 전송
    3. 클라이언트는 대칭키를 공개키로 암호화하여 전송
    4. 서버는 이를 복호화하여 대칭키 확보
    5. 해당 대칭키들로 안전하게 통신

#### 2.2 키 교환 메커니즘

- ##### 디피-헬만 키 교환 암호화 알고리즘
  - y = g^x mod p 에서 g, x, p를 안다면 y는 구하기 쉬우나 g,y,p를 알면 x는 구하기 어렵다는 원리에 기반한 알고리즘
  1. 공개값 공유
  2. 각자의 비밀값과 혼합
  3. 혼합값 공유
  4. 각자의 비밀값과 혼합
  5. 공통의 암호키 생성

#### 3. 해싱 알고리즘

- 데이터를 추정하기 힘든 더 작고, 섞여있는 조각으로 만드는 알고리즘
- SHA-256, SHA-384 알고리즘 사용
- 0-RTT : TLS 1.3은 사용자가 이전에 방문한 사이트로 다시 방문한다면 SSL/TLS에서 보안 세션을 만드는 통신을 하지 않아도 됨
  <br>

  - 해시 : 다양한 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑한 값
  - 해싱 : 임의의 데이터를 해시로 바꿔주는 일로 해시함수가 이를 담당 \* 해시 함수 : 임의의 데이터를 입력으로 받아 일정한 길이의 데이터로 바꿔주는 함수

- ##### SHA-256 알고리즘
  - 해시 함수의 "결과값이 256 비트"인 알고리즘
  - 비트코인을 비롯한 블록체인 시스템에서도 사용
  - 해싱 대상 메시지 전처리 후 해당 값의 해시 반환
  - 예시
    - 원문 : 안녕 나는 해내고 말꺼야!
    - 해시 : E826ACA909F690FB654216E73F02F1108484930C9B7D1EC593DA88BD7578B509

### HTTPS 구축 방법

1. 직접 CA에서 구매한 인증서 기반으로 HTTPS 서비스 구축
2. 서버 앞단에 HTTPS를 제공하는 **로드밸런서**를 두어 구축
3. 서버 앞단에 HTTPS를 제공하는 **CDN**을 두어 구축

### 2.5.5 HTTP/3.0

- HTTP/2 : TCP 기반
- HTTP/3 : QUIC 계층 위 & UDP 기반

  - QUIC (전송 계층 프로토콜)
    - Google에서 생성
    - 왜 UDP?
      - TCP : 신뢰성은 확보되나 지연을 줄이기 힘든 구조 (Header 부터 복잡)
      - UDP : 데이터 전송에 집중한 설계로 별도의 기능 X, 원하는 기능 구현 가능
      - TCP의 지연을 줄이면서 TCP만큼 신뢰성 확보 가능
    - 순방향 오류 메커니즘 (FEC : Foward Error Correction)
      - 전송 패킷 손실시 수신 측에서 에러 검출하여 수정
      - 열악한 환경에서도 낮은 패킷 손실률
  - 장점
    - 전송 속도 향상 : 첫 연결 설정에서 필요한 정보와 데이터를 동시에 보냄 && 연결 성공 시 설정을 캐싱하여 다음 연결 때 바로 성립 가능
      - Connection UUID : 고유 식별자로 서버와 연결되어 IP 가 바뀌어도 커넥션 재수립 필요가 없음
    - 보안성 향상
      - TLS 기본 적용
      - IP Spoofing / Replay Attack 방지
    - 멀티플렉싱 개선
      - 요청 별 독립 스트림 생성하여 HOL Blocking 추가 방지

- 멀티 플렉싱 지원
- "초기 연결 설정 시 지연 감소" 라는 대표적 장점 보유
  - 초기 연결시 1 RTT만 필요
  - 3WAY Handshake 필요 없음 (3 RTT 소요)

<https://velog.io/@pilyeooong/HTTP2%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90>
