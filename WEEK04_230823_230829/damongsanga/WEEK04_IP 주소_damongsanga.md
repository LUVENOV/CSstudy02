## 2.4 IP 주소

### 2.4.1 ARP (Address Resolution Protocol)

: IP 주소로부터 MAC 주소를 구하는 IP와 MAC 주소 다리 역할을 하는 프로토콜

- ARP : IP (논리적 주소) > MAC (물리적 주소)
- RARP : MAC (물리적 주소) > IP (논리적 주소)

IP 주소에서 MAC 주소를 찾아 MAC 주소 기반으로 통신
** 같은 네트워크 대역에서 통신하더라도 7계층 캡슐화를 통해 데이터를 보내야 함, **IP 주소와 MAC 주소 모두 필요\*\*
이때 IP 주소는 알고 MAC 주소는 몰라도 ARP 를 통해 통신이 가능

#### ARP 프로토콜의 구조

: 28 Byte

**< 고정값 >**

- **Hardware Type :** 2계층에서 사용하는 프로토콜 타입 (보통 이더넷 : 00 01)
- **Protocol Type :** (IPv4 : 08 00)
- **Hardware Address Length :** 06 (MAC 주소: 6 Byte)
- **Protocol Address Length :** 04 (IPv4 주소 : 4 Byte)

**< 변동값 >**

- **Opcode :** 물어볼 시에 1, 응답할 시에 2
- **Source Hardware Address :** 출발지 MAC 주소
- **Source Protcol Address :** 출발지 IPv4 주소
- **Destination Hardware Address :** 목적지 MAC 주소
- **Destination Protcol Address :** 목적지 IPv4 주소

\*\* 이더넷 외에 다른 프로토콜은 모두 출발지가 먼저 온다

#### ARP 프로토콜 통신 방법

**< Eth & ARP에서 목적지 MAC 주소 어떻게 암? >**

1. 요청 호스트 : Eth + ARP 요청 프로토콜 생성 - **ARP : 0000으로 비워둠** - **Eth : FFFF FFFF FFFF 으로 보냄 (1로 채워둠)** >> **브로드캐스트 (모든 주소의 마지막 값은 브로드캐스트)** - 같은 네트워크대역에 있는 모든 PC에 보냄
   <br>
2. 스위치 (대표적인 2계층 장비) 가 이를 받아서 2계층까지만 디캡슐레이션함
   & 목적지 MAC 주소가 브로드캐스트이기 때문에 같은 LAN 내에 있는 모든 PC 에게 보냄, **여기서 다른 LAN으로 나가지 않는다**
   <br>
3. 모든 PC가 2, 3계층을 모두 까봄
   여기서 본인의 IP주소와 **ARP의 목적지 IP 주소가 일치하지 않는 경우 패킷을 버림**
   <br>
4. 목적지에 해당되는 호스트는 응답 프로토콜을 만들어 **유니캐스트 방식**으로 전송
   (Opcode 2, 본인 MAC 주소 적어서 보냄, Eth에서는 목적지 MAC 주소를 확실히 줌 aa:aa:aa:aa:aa:aa)
   <br>
5. 프로토콜을 받은 A는 ARP 캐시 테이블에 C의 IP주소와 MAC주소를 연동해서 저장

- 브로드캐스트 : 송신 호스트가 전송한 데이터를 네트워크에 연결된 모든 호스트에 전송하는 방식
- 유니캐스트 : 고유 주소로 식별된 하나의 네트워크 목적지로 1:1 데이터를 전송하는 방식

### ARP 캐시 테이블

- 통신했던 컴퓨터의 주소는 ARP 캐시 테이블에 남게되고, 일정 시간이 지나면 사라지게 된다.
- 수동으로 따로 영구 등록이 가능하다.
- 이후 운영체제는 ARP 캐시 테이블을 참조해 ping 데이터를 유니캐스트 방식에 따라 게이트웨이까지 전송
- ping : 출발지 호스트와 목적지 호스트 사이에서 회선의 연결 상태나 목적지 운영체제의 동작 여부 등을 점검하기 위해 사용(ICMP를 알면 더 잘 이해할 수 있다.)

#### 요약

1. 같은 LAN영역에 있는지 없는지 판단 (스위칭 통신 대상 (같은 LAN) 인지 라우팅 통신 대상 (다른 LAN) 인지).

2. 운영체제는 **ARP 캐시 테이블**에 접근해 목적지 맥주소를 검색.

   2-1. ARP캐시 테이블에 목적지 맥주소가 있다면 운영체제는 곧바로 해당 맥 주소를 참조해 목적지까지 **유니캐스트 방식**으로 전송.

   2-2. 만약 목적지 맥주소가 없다면, 운영체제는 자신이 속한 LAN영역 전체를 대상으로 **ARP 브로드캐스트 질의**를 전송.

   - 같은 LAN영역에 있으면 바로 자신이 속한 LAN영역 전체에 **브로드캐스트 방식**으로 ARP질의 전송
     (**목적지 주소는 실제 IP주소, 스위칭 통신**),

   - 다른 LAN영역에 있으면 **목적지 IP를 라우터의 IP주소로 변경 후** 자신이 속한 LAN영역 전체에 브로드캐스트 방식으로 ARP질의 전송.
     (**목적지 주소는 라우터의 IP주소, 라우팅 통신**)

3. 질의를 받은 LAN영역의 모든 호스트 중 해당 IP주소를 가진 게이트웨이가 자신의 맥주소를 **유니캐스트 방식**으로 출발지 호스트에게 전송.

4. 목적지 호스트로부터 응답받은 출발지 호스트는 자신의 ARP캐시 테이블에 이러한 내용 반영.

5. ARP캐시 테이블에 목적지 맥주소가 올라오면 운영체제는 사용자가 실제로 전송하고자 하는 데이터를 **유니캐스트 방식**에 따라 목적지 호스트에게 전송.

### 2.4.2 홉바이홉 통신

: IP 주소를 통해 통신하는 과정, 통신망에서 각 패킷이 여러 개의 라우터를 건너가는 모습을 비유적으로 표현한 것
수많은 서브네트워크 안에 있는 라우터의 라우팅 테이블 IP를 기반으로 패킷을 전달하고 , 또 전달해 나가며 라우팅을 수행하여 최종 목적지까지 패킷을 전달

- ##### 라우팅 테이블 : 패킷 경로선택의 근거

  송신지에서 수신지까지 도달하기 위해 사용되며 라우터에 들어가 있는 목적지 정보들과 그 목적지로 가기 위한 방법이 들어있는 리스트
  게이트웨이와 모든 목적지에 대해 해당 목적지에 도달하기 위해 거쳐야 할 다음 라우터의 정보를 가지고 있음

  - netstart -r (window)

- ##### 게이트웨이 (라우터)
      서로 다른 통신망, 프로토콜을 사용하는 네트워크 간의 통신을 가능하게 하는 관문 역할을 하는 컴퓨터나 소프트웨어를 두루 일컫는 용어
      * 게이트웨이-소프트웨어적인 속성에 집중,
      * 라우터-하드웨어적인 속성에 집중.
      * 라우팅 : 라우터가 인터넷 공간에서 각기 다른 호스트 사이를 연결해주는 기능을 수행.
  **>>> 서로 다른 네트워크ID를 사용하는 LAN영역 사이를 연결해주는 기능!**
  <br>
- LAN 영역 : **네트워크 ID (공인 IP) 를 공유**하는 장치들의 집합체를 이루는 공간. 동일한 네트워크 ID를 공유하는 장치들의 집합적 공간 또는 동일한 게이트웨이 주소를 사용하는 장치들의 집합적 공간.(PC와 게이트웨이 사이에 설정한 네트워크 ID동일.)

  => 상이한 네트워크 ID를 사용하는 것은 상이한 LAN영역에 있다는 것을 의미.
  쉽게 얘기하면 호스트 사이에서 동일한 네트워크 ID를 공유하는 공간이라 할 수 있다.
  <br>

- **네트워크 ID :** 무수한 LAN영역에서 **자기 LAN영역을 구분**하기 위한 식별자 또는 해당 LAN영역을 식별하는 고유 IP 주소 대역을 의미.
  ⇒ LAN 영역 식별의 기준.
- **호스트 ID :** 해당 LAN영역에 속한 호스트 각각을 구분하기 위한 식별자.
  ⇒ 해당 LAN 영역에 속한 호스트를 구분하기 위한 식별자.

          네트워크 : <고속도로>
          switch : <교차로>  (L3 switch == 라우터)
          switching (인터페이스 선택) : <경로선택>
          Internet = 라우터 집합체 = L3 switch의 집합체*

### 2.4.3 IP 주소 체계

- Ipv4 : 32bit (123.45.67.89)
- Ipv6 : 64bit (2001:db8::ff00:42:8329)

#### Classful IP 주소 (A ~ E)

: 초기 IP 주소, 낭비가 심함
**n번째 필드로 네트워크를 구분함**

- A : 0XXXXXXX 128개 네트워크 (but 1개의 네트워크에 2^24개의 개별 iP 주소)
- B : 10XXXXXX 64\*256 개 네트워크 (A클래스보다 하나의 네트워크에 속한 PC의 수는 2^8배 수만큼 줄어듬)
- C : 110XXXXX
- D : 1110XXXX 멀티캐스트 통신
- E : 1111XXXX 예비용 통신
  **>>> 클래스가 낮아질수록 네트워크의 수는 늘어나고 하나의 네트워크에 속할 수 있는 PC의 수는 줄어든다**
  **>>> 만약 A클래스 네트워크에 컴퓨터가 1대라면 약 1600만개의 IP주소가 낭비됨**

* 구분 비트 : 맨 왼쪽에 있는 비트 (A : 0, B : 10, C : 110)
* 가장 첫 번째 주소는 네트워크 주소, 가장 마지막 주소는 브로드캐스트용 주소

* 예시
  A class 12.0.0.0 네트워크 부여시 12.0.0.1 ~ 12.255.255.254 호스트 주소부여
  12.0.0.0은 네트워크 구별주소, 12.255.255.255는 브로드캐스트용
  낭비가 너무 심함!

* 개선
  - DHCP
  - NAT

#### DHCP (Dynamic Host Configuration Protocol)

IP 주소 및 기타 통신 매개변수를 자동으로 할당하기 위한 네트워크 관리 프로토콜
이를 통해 네트워크 장치의 IP 주소를 수동으로 설정할 필요 없이 인터넷에 접속할 떄마다 자동으로 IP 주소 할당
라우터와 게이트웨이 장비에 DHCP 기능 존재하여 가정용 네트워크에서 IP 주소 할당

DHCP에 대한 표준은 RFC문서에 정의
DHCP는 네트워크에 사용되는 IP주소를 DHCP서버가 중앙집중식으로 관리하는 클라이언트/서버 모델 사용
DHCP지원 클라이언트는 네트워크 부팅과정에서 DHCP서버에 IP주소를 요청하고 이를 얻을 수 있음

네트워크 안에 컴퓨터에 자동으로 네임 서버 주소, IP주소, 게이트웨이 주소를 할당해주는 것을 의미하고, 해당 클라이언트에게 일정 기간 임대를 하는 동적 주소 할당 프로토콜입니다.

- 장점
  - PC의 수가 많거나 PC 자체 변동사항이 많은 경우 IP 설정이 자동으로 되기 때문에 효율적으로 사용
  - IP를 자동으로 할당하여 IP 충돌 방지
- 단점
  - DHCP 서버에 의존되기 때문에 서버가 다운되면 IP 할당이 제대로 이루어지지 않음

#### NAT (Network Address Translation)

: 패킷이 라우팅 장치를 토앻 전송되는 동안 패킷의 IP 주소 정보를 수정하여 IP 주소를 다른 주소로 매핑하는 방법
NAT로 **공인 IP와 사설 IP**로 나눠서 많은 주소를 처리

사설 IP ⇒ 공인 IP 변환 (정확히는 특정 IP를 특정 IP로 변환하는 기술)
실제 인터넷 세상에서 바라보았을 때 공인 IP로만 통신하여 사설 IP는 보이지 않기 때문에 클라이언트에서 서버로 요청할 때 사설 IP를 사용하면 서버에서는 어느 게이트웨이로 패킷을 보내줘야하는지 알 수 없다.
**: 나갔다가 들어오는 것은 통신이 되지만 일반적으로는 밖에서 직접적으로 들어올 수 없다 (밖에서는 안이 안보이기 때문) 그래서 서버는 보통 공인 IP를 사용한다**

- 공인 IP : 인터넷과 통신할 때 사용하는 IP 주소 ( ex Naver 통신시 내 IP )
- 사설 IP : 같은 네트워크 대역에서 사용하는 IP 주소 ( ex cmd 창에서 검색했을 시의 IP )
  <br>
- 사용 목적 : 여러 대의 호스트가 하나의 공인 IP주소를 사용하여 인터넷에 접속하기 위함
- 공유기 : NAT을 통해 인터넷 회선 하나를 개통하고 인터넷 공유기를 달아서 여러 PC를 연결하여 사용
- 보안 : 내부 네트워크에서 사용하는 IP 주소와 외부에 드러나는 IP 주소를 다르게 유지하여 내부 네트워크에 대한 보안 유지 가능
- 단점 : 여러 명이 동시에 인터넷이 접속 가능하여 접속 호스트 수에 따라 접속속도가 느려질 수 있음
  <br>
- 공유기에 요청한 데이터가 아닌 데이터를 받았다면? : 공유기에 NAT 테이블을 확인하여 요청한 데이터가 아닐 경우 전달해주지 않는다

**NAT 사용 이유 요약**

1. IP 주소 절약 : 공유기에 NAT 기능 탑재되어있어 하나의 공인 IP 주소 사용하여 여러 대의 호스트가 인터넷 접속 가능
2. 보안 : 사설 IP 보호 가능

#### IPv4 프로토콜의 구조 (20 Byte + a(4 Byte씩) )

- **Version :** 4 (IPv6은 구조 자체가 달라서 6이 오는 경우는 없음)
- **IHL (Heather Length) :** 최소 20 Byte ~ 최대 60 Byte이나 4 Bit로는 최대 15까지밖에 표기하지 못하기 때문에 4로 나눈 값을 저장해줌 >> 보통 5
- **Type of Service :** 00 (과거에 사용했던 정보)
- **Total Length :** 페이로드까지의 총 길이

**< 패킷의 조각화 관련 정보 >**

- **Identification** : 쪼개진 패킷을 합칠 때 원래 같은 data였다는 것을 알려주는 정보
- **IP Flags (3 Bit)** : x > 안씀, D > 쪼개지 않는다, M > 쪼갠다

  - 쪼개지 않으면 전송이 안되는 경우가 많음 : 따라서 \*\*거의 M만 쓰게 된다 (001)

- **Fragment Offset (13 Bit)** : 쪼개진 패킷을 원래대로 복구할 때의 순서, 시작으로부터 얼마나 떨어져있는지

  - 예를 들어 1번째 조각은 0, 2번째 조각은 1번째 조각 크기만큼 …

- **Time To Live (TTL) :** 작성 오류로 인해 패킷이 순환하여 쌓이는 경우를 방지하기 위해 패킷 생존 시간(전송 횟수) 제한

  - 이걸로 상대방 운영체제를 알 수 있음 (Windows : 128, Linux : 64)

- **Protocol :** 상위 프로토콜이 뭔지 알려줌 (ICMP : 1 / **TCP : 6** / UDP : 17)
- **Header Checksum :** Header가 오류가 있는지 체크

- **Source Address :** 출발지 IP 주소
- **Destination Address :** 도착지 IP 주소

#### IPv4의 조각화

: 큰 IP 패킷들이 작은 **MTU (Maximum Transmission Unit, 일반적으로 1500 Byte)**를 갖는 링크를 통해 전송되려면 여러 개의 작은 패킷으로 조각화되어 전송

(1500 Byte 이상의 페이로드를 가지는 데이터 등)

**즉, 목적지까지 패킷을 전달하는 과정에 통과하는 각 라우터마다 전송에 적합한 프레임으로 변환 필요**

- 일단 조각화되면, 최종 목적지에 도달할 때까지 재조립되지 않는 것이 일반적
- IPv4에서는 발신지 뿐만 아니라 중간 라우터에서도 IP 조각화가 가능
- IPv6에서는 IP 단편화가 발신지에서만 가능
- 재조립은 항상 최종 수신지에서만 가능
  <br>
- **MTU : TCP 헤더 + IP 헤더 포함됨**
- **MSS (Maximum Segment Size) : MTU - (TCP 헤더 + IP 헤더)**

#### 조각화의 예시 (2회)

EX) 1회차 3300 byte MTU, 2회차 1300 byte MTU일 때

- ### **1회차 기준 IPv4 프로토콜이 들어가기 위한 20 byte 제외한 11980 byte 페이로드를 3280(MSS)씩 쪼갠다**
- MF (More Flag) : 내 뒤에 패킷이 더 있다
- Offset : 전 패킷들의 data 크기 / 8
- **여기서 4개의 패킷의 IPv4 protocol은 동일하다**

### 조각화 과정

- MTU를 넘는 data는 한 번에 보낼 수 없다
- **IPv4까지 합친 크기가 MTU이하가 되도록 (== Data가 MSS 이하가 되도록) 패킷을 조각화하고 Ethernet 프로토콜을 합쳐서 전송한다 (1514 Byte)**
- **마지막 패킷에 ICMP (8 byte) 붙음**
- **ID 동일, MF는 1과 0인데 여기서 2가 되는 이유는 3bit가 001인데 이를 16진수(4bit)로 끊어 읽으면 0010 이 되어 10진수로 2로 표기된다.**

### 조각화 문제

보내려는 크기 : 2379 byte, MTU = 980 byte

1. 몇 개의 패킷으로 쪼개지는가? 2379 / (980-20) = 3.xx ⇒ 4개
2. 첫 번째 패킷의 데이터의 크기는 몇인가? 960 byte
3. 마지막 패킷의 데이터의 크기는 몇인가? 459 byte
