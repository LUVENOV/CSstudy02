## 4.3 트랜잭션과 무결성

### 4.3.1 트랜잭션

- 트랜잭션

  - 데이터 베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위
  - 여러개의 커리를 하나로 묶는 단위

- ACID 특징
  - 원자성
  - 일관성
  - 독립성
  - 지속성

##### 원자성

- **ALL OR NOTHING**
- 트랜잭션과 관련된 일이 모두 수행되었거나 or 되지 않았거나를 보장하는 특징
- 일부 작업을 취소했다고 하더라고 중간 과정에서 멈추지 않고 시작이나 끝 상태만 가질 수 있도록 보장
- 트랜잭션 단위로 여러 로직들을 묵을 때 외부 API를 호출하면 안된다

  - 만약 존재한다면 롤백이 일어났을 대 어떻게 해야 할 것인지 해결 방법이 반드시 존재해야

- 커밋과 롤백

  - 커밋 (commit)
    - 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어
    - 트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장
    - 커밋이 수행됨 == 하나의 트랜잭션이 성공적으로 수행됨
    - 커밋이 시작되고 update & insert & delete 쿼리들이 하나의 트랜잭션 단위로 수행되며 완료시 커밋이 종료 -> 데이터베이스 영구장됨
  - 롤백
    - 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌리는 일 (최소)
    - 에러나 여러 이슈 때문에 트랜잭션 전으로 돌려야 할 때 사용, 아예 커밋 시작 전으로 돌려놓음!
  - 커밋과 롤백으로 데이터의 무결성 보장 가능

- 트랜잭션 전파

  - 트랜잭션 수행 단위는 커넥션으로 커넥션 객체를 매번 넘겨주지 않도록 여러 트랜잭션 관련 메거드의 호출을 하나의 트랜잭션에 묶이도록 하는 것
  - Spring에서 @Transactional 애너테이션을 통해 여러 쿼리 관련 코드들을 하나의 트랜잭션으로 처리

  ```java
  @Service
  @Transcational(readOnly=true)
  public class MemberService {

  }
  ```

##### 일관성

- 허용된 방식으로만 데이터를 변경해야 하는 것
- 데이터베이스에 기록된 모든 데이터는 여러가지 조건, 규칙에 따라 유효함을 가져야
- 예시로 잔고가 0원인데 500만원을 송금할 수 있도록 허용하면 안된다

##### 격리성

- 트랜잭션 수행 시 서로 끼어들이 못한다
- 복수의 병렬 트랜잭션은 서로 격리되어 마치 순차적으로 수행되는 것처럼 작동되어야
- 데이터베이스는 여러 사용자가 같은 데이터에 접근할 수 있어야

* 격리성으로 발생될 수 있는 문제점
  1. **Dirty Read**
  - 다른 트랜잭션에 의해 수정되었으나 커밋되지 않은 데이터를 읽는 것
  - A 트랜잭션이 수정한 값을 B 트랜잭션이 읽었으나 A가 롤백해버리면 B는 잘못된 값을 가진 채 본인의 로직을 처리해버림 2.**Non-Repeatable Read**
  - 한 트랜잭션 내에서 같은 Key를 가진 Row를 두번 읽었으나 그 사이에 값이 변경되거나 삭제되어 결과가 다르게 나타나는 것
  - A 트랜잭션이 값을 2번 읽었는데 그 사이에 B가 해당 값을 수정후 커밋하면 A는 같은 값을 읽었으나 다른 값으로 로직을 처리하게 됨
  3. **Phantom Read**
  - 한 트랜잭션 내에서 같은 쿼리를 두 번 수행했는데, 첫 번재 쿼리에서 없던 유령 레코드가 두 번째 쿼리에서 나타나는 현상
  - A 트랜잭션이 같은 쿼리를 두 번 요청했는데 그 사이에 B 트랜잭션이 해당 쿼리를 삽입해버리면 원래 A는 해당 레코드를 찾지 못해야 하나 두번 째 쿼리에서 찾을 수 있게 되버림
  - 2와 3번의 차이
    - Non-Repetable Read : 행 값이 달라질 수 있음
    - Phantom Read : 다른 생이 선택되어 버릴 수 있음

- 여러 격리 수준으로 나누어 격리성 보장 (기술순서 위로 갈 수록 격리성은 강해지고 동시성은 약해짐)

  - **SERIALIZABLE**

    - 말 그대로 트랜잭션을 순차적으로 진행시키는 것
    - 트랜잭션이 동시에 같은 행 접근 자체를 불가시킴
    - 트랜잭션 내에서 쿼리를 두번 이상 수행할 때, 첫 번째 쿼리에 있던 레코드가 사라지거나 값이 바뀌지 않음은 물론 새로운 레코드가 나타나지도 않게 설정하는 것
    - 문제 발생 X
    - 그러나 성능이 매우 느리고 교착상태 발생 가능성 높음

  - **REPEATABLE_READ**

    - 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아줌 (Non-repetable Read 해결)
    - 그러나 새로운 행을 추가하는 것을 막지 않음
    - Phantom Read 발생 가능

  - **READ_COMMITTED**

    - 트랜잭션이 커밋되어 확정된 데이터만 다른 트랜잭션이 읽도록 허용 (dirty read 해결)
    - 가장 많이 사용되는 격리 수준 (MySQL8.0, SQL Server, Oracle 등)
    - 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정할 수도 있음
    - Phantom Read, Non-Reapetable Read 발생 가능

  - **READ_UNCOMMITTED**
    - 트랜잭션에서 처리 중인 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용
    - 정합성에 문제가 많아 권장하지 않으나 속도가 매우 빨라 거대한 양의 데이터를 어림잡아 집계하는데는 사용하기 좋음
    - Phantom Read, Non-Reapetable Read, Dirty Read 발생 가능

##### 지속성

- 성공적으로 수행된 트랜잭션은 영원이 반영되어야
- 시스템 장애가 발생해도 원래 상태로 복구하는 회복기능이 존재해야 함을 의미
- 데이터베이스는 이를 위해 체크섬, 저널링, 롤백 기능 제공
  - checksum : 중복 검사의 한 형태로, 오류 정정을 위해 송신된 자료의 무결성을 보호하는 단순한 방법
    - 주민등록번호 마지막 번호도 일종의 체크섬이다
  - 저널링 : 파일 시스템 도는 데이터베이스 시스템에 변경 사항을 반영(commit)하기 전에 로깅하는 것, 트랜잭션 등 변경 사항에 대한 로그를 남기는 것

### 4.3.2 무결성

- 데이터의 정확성, 일관성, 유효성을 유지하는 것
- 무결성이 유지되어야 데이터베이스에 저장된 데이터값과 그 값에 해당하는 현실 세계의 실제 값이 일치한다는 신뢰 형성
- 스키마를 작성할 떄 무결성 제약조건을 한 번만 명시하면, 데이터베이스가 갱신될 때마다 DBMS가 자동으로 제약조건을 검사하므로 어플리케이션들은 제약조건을 일일이 검사할 필요가 없음
- 종류
  - 개체 무결성 : 기본키 설정 필드는 빈 값을 허용하지 않음
  - 참조 무결성 : 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야
  - 고유 무결성 : 특정 속성에 대해 고유한 값을 가지도록 주어진 경우, 그 속성 값은 모두 고유한 값을 가짐
    - 예시로 이름, 나이는 같은 값이 있을 수 있어도 학번은 안됨
  - NULL 무결성 : 특정 속성 값에 NULL이 올 수 없다는 조건이 주어지면, 그 속성 값은 NULL이 되면 안됨
  - 도매인 무결성 : 테이블에 존재하는 필드의 데이터 타입에 맞아야
    - 예시로 성별이라는 속성에서 '남', '여'를 제외한 데이터는 제한되어야
