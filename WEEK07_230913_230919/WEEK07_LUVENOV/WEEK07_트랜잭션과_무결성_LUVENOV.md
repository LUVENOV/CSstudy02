# WEEK07_트랜잭션과 무결성

---

# 4.3 트랜잭션과 무결성

---

## 4.3.1 트랜잭션

- 데이터베이스에서 하나의 논리적 기능 수행을 위한 작업 단위
- 데이터베이스에 접근하는 방법은 쿼리이므로 여러 개의 쿼리들을 하나로 묶는 단위
- **ACID 특징 :** 원자성, 일관성, 독립성, 지속성

### 원자성(Atomicity)

- “all or nothing”
- 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징
    
    ex ) 트랜잭션을 커밋했는데 문제가 발생하여 롤백 시 그 이후 모두 수행 X
    
- 트랜잭션 단위로 여러 로직들을 묶을 때 외부 API를 호출 X
    
    → 있다면 롤백 시 어떻게 해야 할 것인지에 대한 해결 방법 및 트랜잭션 전파 관리 필요
    

**커밋과 롤백**

- 커밋(commit)
    - 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어
    - 트랜잭션 단위로 수행되며 변경 내용이 모두 영구적으로 저장
    - “커밋이 수행되었다” = “하나의 트랜잭션이 성공적으로 수행되었다”
    - updte, insert, delete의 쿼리가 하나의 트랜잭션 단위로 수행 후 데이터베이스에 영구 저장
- 롤백
    - 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌리는 일(취소)
    - 에러나 여러 이슈로 트랜잭션 전으로 돌려야 함

![Untitled](WEEK07_%E1%84%90%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8C%E1%85%A2%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%20%E1%84%86%E1%85%AE%E1%84%80%E1%85%A7%E1%86%AF%E1%84%89%E1%85%A5%E1%86%BC%20a4ea18ff87944a9197eb74ed7af80a88/Untitled.png)

→ 커밋과 롤백 덕에 데이터의 무결성 보장 및 데이터 변경 전에 변경 사항 확인 및 작업 그룹화 가능

**트랜잭션 전파**

- 트랜잭션은 커넥션 단위로 수행하기 때문에 커넥션 객체를 넘겨서 수행하는데, 이를 매번 넘겨주기 어렵고 귀찮음
- 커넥션 객체를 넘겨서 수행하지 않고 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것

**일관성(consistency)**

- ‘허용된 방식’으로만 데이터를 변경해야 하는 것
- 데이터베잇으에 기록된 모든 데이터는 여러 가지 조건, 규칙에 따라 유효함을 가져야 함

**격리성(isolation)**

- 트랜잭션 수행 시 서로 끼어들지 못하는 것
- 복수의 병령 트랜잭션은 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동되어야 함
- 데이터베이스는 여러 사용자가 같은 데이터에 접근 가능해야 함 → 순차 접근은 성능 ↓
- 격리성은 여러 개의 격리수준으로 나뉘어 격리성 보장

![Untitled](WEEK07_%E1%84%90%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8C%E1%85%A2%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%20%E1%84%86%E1%85%AE%E1%84%80%E1%85%A7%E1%86%AF%E1%84%89%E1%85%A5%E1%86%BC%20a4ea18ff87944a9197eb74ed7af80a88/Untitled%201.png)

→ 위로 갈수록 동시성 증가 격리성 감소, 아래로 갈수록 동시성 감소 격리성 증가

- 단계별로 나타나는 현상 존재
    - REPEATABLE_READ : 팬텀 리드
    - READ_COMMITTED : 팬텀 리드, 반복 가능하지 않은 조회
    - READ_UMCOMMITTED : 팬텀 리드 ,반복 가능하지 않은 조회, 더티 리드

※격리 수준에 따라 발생하는 현상

1. **팬텀 리드(Phantom read)**
- 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우
    
    ex ) 사용자 A가 회원 테이블에서 age가 12 이상인 회원들을 조회하는 쿼리를 보내고 결과로 세 개의 테이블 조회 후 사용자 B가 age가 15인 회원 레코드 삽입 시 네 개의 테이블이 조회 됨
    
1. **반복 가능하지 않은 조회(non-repeatable read)**
- 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데, 그 값이 다른 경우
    
    ex) 사용자 A가 큰돌의 보석 개수가 100개라는 값을 가진 데이터였는데, 이후 사용자 B가 해당 값을 1로 변경해서 커밋했다고 하면 사용자 A는 100이 아닌 1을 읽게 됨
    
- 팬텀 리드와의 차이점 : 반복 가능하지 않은 조회는 행 값이 달라질 수 있는데, 팬텀 리드는 다른 행이 선택될 수도 있음
1. **더티 리드(dirty read)**
- 반복 가능하지 않은 조회와 유사하며 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 ‘커밋되지 않은’ 행의 데이터를 읽을 수 있을 때 발생
    
    ex ) 사용자 A가 큰돌의 보석 개수 100을 1로 변경한 내용이 ‘커밋되지 않은’ 상태라도 그 이후 사용자 B가 조회한 결과가 1로 나오는 경우
    

※격리 수준

1. **SERIALIZABLE**
- 트랜잭션을 순차적으로 진행시키는 것
- 여러 트랜잭션이 동시에 같은 행 접근 불가
- 매우 엄격한 수준으로 해당 행에 대해 격리시키고, 이후 트랜잭션이 이 행에 대해 일어난다면 기다려야 함
- 교착 상태가 일어날 확률도 많고 가장 성능이 떨어지는 격리 수준
1. **REPEATABLE_READ**
- 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정 불가하도록 막아주지만 새로운 행을 추가하는 것을 막지 않음 → 이후에 추가된 행이 발견될 수 있음
1. **READ_COMMITTED**
- 가장 많이 사용되는 격리 수준 (MySQL8.0, PostgreSQL, SQL Server, 오라클 기본값)
- 커밋 완료된 데이터에 대해서만 조회 허용 (다른 트랜잭션이 커밋하지 않은 정보 읽기 불가)
    
    ↔ READ_UNCOMMITTED 
    
- 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정 가능
1. **READ_UMCOMMITTED**
- 가장 낮은 격리 수준
- 하나의 트랜잭션이 커밋 이전에 다른 트랜잭션에 노출되는 문제가 있으나 가장 빠름
- 데이터 무결성을 위해 되도록이면 사용 X
- 몇몇 행이 제대로 조회되지 않아도 되는 거대한 양의 데이터를 ‘어림잡아’ 집계 시 사용할 때 효율적

### 지속성(Durability)

- 성공적으로 수행된 트랜잭션은 영원히 반영
- 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 함
- 체크섬, 저널링, 롤백 등의 기능 제공

** 체크섬 : 중복 검사의 한 형태로, 오류 정정을 통해 송신된 자료의 무결성을 보호하는 단순한 방법

** 저널링 : 파일 시스템 또는 데이터베이스 시스템에 변경 사항을 반영(commit)하기 전에 로깅하는 것, 트랜잭션 등 변경 사항에 대한 로그를 남기는 것

## 4.3.2 무결성

- 데이터의 정확성, 일관성, 유효성을 유지하는 것
- 무결성이 유지되어야 데이터베이스에 저장된 값과 그 값에 해당하는 현실 세계의 실제 값이 일치하는 지에 대한 신뢰가 생성
- 무결성 종류

| 이름 | 설명 |
| --- | --- |
| 개체 무결성 | 기본키로 선택된 필드는 빈 값을 허용하지 않음 |
| 참조 무결성 | 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값 유지 필요 |
| 고유 무결성 | 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값을 가짐 |
| NULL 무결성 | 특성 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 될 수 없음 |