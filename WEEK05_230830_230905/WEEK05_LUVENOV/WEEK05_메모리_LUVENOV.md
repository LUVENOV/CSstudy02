# WEEK05_메모리

---

# 3.2 메모리

---

- CPU는 ‘메모리’에 올라와 있는 프로그램의 명령어들을 실행할 뿐

## 3.2.1 메모리 계층

- 레지스터, 캐시, 메모리, 저장장치로 구성
    - **레지스터** : CPU 안에 있는 작은 메모리, 휘발성, 속도 가장 빠름, 기억 용량 가장 ↓
    - **캐시** : L1, L2 캐시 지칭, 휘발성, 속도 빠름, 기억 용량 ↓, L3 캐시도 존재
    - **주기억장치**  : RAM, 휘발성, 속도 보통, 기억 용량 보통
    - **보조기억장치** : HDD, SSD, 비휘발성, 속도 낮음, 기억 용량 ↑

![Untitled](WEEK05_%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%2087414011882c4e25b7d6cd1b5733bd46/Untitled.png)

- RAM은 하드디스크로부터 일정량의 데이터 복사, 임시 저장 후 필요 시마다 CPU에 빠르게 전달
- 계층 위로 올라갈수록 가격 증가 → 용량은 작아지고 속도는 빨라짐
- 계층 존재 이유 : 경제성과 캐시 때문

### 캐시(cache)

- 데이터를 미리 복사해놓는 임시 저장소
- 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리
- 데이터를 접근하는 시간이 오래 걸리는 경우 해결 및 무언가를 다시 계산하는 시간 절약 가능
    - 메모리와  CPU의 속도 차이가 너무 크므로 중간에 레지스터 계층을 두어 속도 차이 해결
    - 속도 차이 해결을 위한 계층과 계층 사이의 계층을 캐싱 계층이라고 함
        
        ex ) 캐시 메모리와 보조기억장치 사이의 주기억장치가 보조기억장치의 캐싱 계층
        

**지역성의 원리**

- 캐싱 계층을 두는 것 말고 직접 설정 시 → 자주 사용하는 데이터 기반 설정
- 시간 지역성(temporal locality)와 공간 지역성(spatial locality)로 분리

시간 지역성

- 최근 사용한 데이터에 재접근하려는 특성

공간 지역성

- 최근 접근한 데이터를 이루고 있는 공간 혹은 가까운 공간에 접근하는 특성

### 캐시 히트와 캐시 미스

- 캐시 히트 : 캐시에서 원하는 데이터를 찾은 경우
- 캐시 미스 : 해당 데이터가 캐시에 존재하지 않아 메모리로 가서 데이터를 찾아오는 것

![Untitled](WEEK05_%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%2087414011882c4e25b7d6cd1b5733bd46/Untitled%201.png)

- 캐시 히트 시 해당 데이터를 제어장치를 거쳐 가져오며, 위치도 가깝고 CPU 내부 버스 기반으로 작동하므로 빠름
- 캐시 미스 발생 시 메모리에서 가져오므로 시스템 버스를 기반으로 작동하므로 느림

**캐시 매핑**

- 캐시가 히트되기 위해 매핑하는 방법으로, CPU의 레지스터와 주 메모리(RAM) 간에 데이터를 주고받을 때를 기반으로 설명
- 레지스터는 주 메모리에 비하면 굉장히 작고 주 메모리는 굉장히 크므로 작은 레지스터가 캐시 계층으로써 역할을 잘 하려면 매핑을 어떻게 하는지가 중

| 이름 | 설명 |
| --- | --- |
| 직접 매핑 (directed mapping) | 메모리가 1~100이 있고 캐시가 1~10만 있다면 1;1~10, 2:1~20 … 식으로 매핑. 처리가 빠르나 충돌 발생 잦음 |
| 연관 매핑 (associative mapping) | 순서를 일치시키지 않고 관련 있는 캐시와 메모리 매핑. 충돌이 적으나 모든 블록을 탐색해야 하므로 속도 느림 |
| 집합 연관 매핑(set associative mapping) | 직접 매핑 + 연관 매핑. 순서는 일치시키나 집합을 두어 저장하며 블록화되어 있기 때문에 검색은 보다 효율적. 메모리가 1~100, 캐시가 1~10 있을 시 캐시 1~5에는 1~50의 데이터를 무작위로 저장 |

**웹 브라우저의 캐시**

- 소프트웨어적인 대표적 캐시 : 웹 브라우저의 작은 저장소 쿠키, 로컬 스토리지, 세션 스토리지
- 사용자의 커스텀 정보, 인증 모듈 관련 사항들을 웹 브라우저에 저장해 추후 서버 요청 시 아이덴티티나 중복 요청 방지를 위해 사용

쿠키

- 만료기한이 있는 키-값 저장소
- same site 옵션을 strict로 설정하지 않았을 경우 다른 도메인에서 요청 시 자동 전송
- 4KB까지 데이터 저장 가능, 만료 기한 설정 가능
- 쿠키 설정 시 document.cookie로 쿠키를 볼 수 없게 httponly 옵션을 거는 것이 중요
- 클라이언트 또는 서버에서 만료기한 등 설정 가능(보통 서버에서 설정)

로컬 스토리지

- 만료 기한이 없는 키-값 저장소
- 10MB까지 저장 가능, 웹 브라우저 종료되어도 유지, 도메인 단위로 저장/생성
- HTML5 미지원 웹 브라우저에서 사용 불가
- 클라이언트에서만 수정 가능

세션 스토리지

- 만료기한이 없는 키-값 저장소
- 5MB까지 저장 가능, 탭 단위로 세션 스토리지 생성, 탭 종료 시 해당 데이터 삭제
- HTML5 미지원 웹 브라우저에서 사용 불가
- 클라이언트에서만 수정 가능

**데이터베이스의 캐싱 계층**

- 데이터베이스 시스템 구축 시 메인 데이터베이스 위에 레디스(redis) 데이터 베이스 계층을 ‘캐싱 계층’으로 두어 성능 향상

![Untitled](WEEK05_%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%2087414011882c4e25b7d6cd1b5733bd46/Untitled%202.png)

## 3.2.2 메모리 관리

### 가상 메모리(virtual memory)

- 메모리 관리 기법의 하나로 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는

![Untitled](WEEK05_%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%2087414011882c4e25b7d6cd1b5733bd46/Untitled%203.png)

- 가상 주소(logical address) : 가상적으로 주어진 주소
- 실제 주소(physical address) : 실제 메모리상에 있는 주소
- 가상 주소는 메모리관리장치(MMU)에 의해 실제 주소로 변환되며, 사용자는 실제 주소 상관 없이 프로그램 구축 가능
- 가상 메모리는 가상 주소와 실제 주소가 매핑되어 있고 프로세스의 주소 정보가 들어 있는 ‘페이지 테이블’로 관리(속도 향상을 위해 TLB 사용)

** TLB : 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시, 페이지 테이블에 있는 리스트를 보관하며 CPU가 페이지 테이블까지 가지 않도록 해 속도를 향상시킬 수 있는 캐시 계층

**스와핑**

- 메모리에서 당장 사용하지 않는 영역을 하드디스크로 옮기고 하드디스크의 일부분을 메모리처럼 불러와 쓰는 것
- 가상 메모리에는 존재하나 RAM에는 현재 없는 데이터/코드 접근 시 페이지 폴트 발생 → 스와핑을 통해 마치 페이지 폴트가 일어나지 않은 것처럼

**페이지 폴트**

- 프로세스의 주소 공간에는 존재하나 지금 이 컴퓨터의 RAM에는 없는 데이터에 접근 시 발생
1. CPU는 물리 메모리 확인 → 해당 페이지가 없으면 트랩을 발생해서 OS에 전달
2. OS는 CPU 동작 멈춤(인터럽트)
3. OS는 페이지 테이블을 확인하여 가상 메모리에 페이지 존재 여부 확인, 없으면 프로세스 중단 및 현재 물리 메모리에 비어 있는 프레임 존재 여부 확인. 물리 메모리에도 없다면 스와핑 발동
4. 비어 있는 프레임에 해당 페이지 로드, 페이지 테이블 최신화
5. 중단되었던 CPU 재시작

** 페이지 : 가상 메모리를 사용하는 최소 크기 단위

** 프레임 : 실제 메모리를 사용하는 최소 크기 단위

### **스레싱(thrashing)**

- 메모리의 페이지 폴트율이 높은 것을 의미 → 컴퓨터의 심각한 성능 저하 초래

![Untitled](WEEK05_%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%2087414011882c4e25b7d6cd1b5733bd46/Untitled%204.png)

- 메모리에 너무 많은 프로세스가 동시에 올라가게 되면 스와핑이 많이 일어나 발생
- 페이지 폴트가 일어나면 CPU 이용률 감소 → OS가 CPU가 한가하다고 생각해 가용성을 높이기 위해 더 많은 프로세스를 메모리에 올림 → 악순환 반복, 스레싱 발생
- 해결 방법 : 메모리 늘리기, HDD to SSD / OS에서 해결 방법 : 작업 세트, PFF

**작업 세트(workign set)**

- 프로세스의 과거 사용 이력인 지역성(locality)을 통해 결정된 페이지 집합을 만들어 미리 메모리에 로드
- 미리 메모리에 로드 시 탐색 비용 감소, 스와핑 감소 가능

**PFF(Page Fault Frequency)**

- 페이지 폴트 빈도를 조절하는 방법으로 상한선과 하한선 생성
- 상한선 도달 시 프레임 증가, 하한선 도달 시 프레임 감소

### 메모리 할당

- 메모리 프로그램 할당 시 시작 메모리 위치, 메모리 할당 크기 기반 할당
- 연속 할당, 불연속 할당으로 분리

**연속 할당**

- 메모리에 ‘연속적으로’ 공간 할당

![Untitled](WEEK05_%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%2087414011882c4e25b7d6cd1b5733bd46/Untitled%205.png)

- 메모리를 미리 나누어 관리하는 고정 분할 방식과 매 시점 프로그램의 크기에 맞게 메모리를 분할하여 사용하는 가변 분할 방식 존재

고정 분할 방식 (fixed partition allocation)

- 메모리를 미리 나누어 관리하는 방식
- 융통성이 없으며 내부 단편화 발생

가변 분할 방식 (variable partition allocation)

- 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용
- 내부 단편화는 발생하지 않으나 외부 단편화 발생
- 최초적합(first fit), 최적적합(best fit), 최악적합(worst fit)

| 이름 | 설명 |
| --- | --- |
| 최초적합 | 위쪽이나 아래쪽부터 시작해 홀을 찾으면 바로 할당 |
| 최적적합 | 프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당 |
| 최악적합 | 프로세스의 크기와 가장 많이 차이 나는 홀에 할당 |

** 내부 단편화(internal fragmentation) : 메모리를 나눈 크기보다 프로그램이 작아서 들어가지 못하는 공간이 많이 발생하는 현상

** 외부 단편화(external fragmentation) : 메모리를 나눈 크기보다 프로그램이 커서 들어가지 못하는 공간이 많이 발생하는 현상(100MB를 55, 45로 나눴으나 프로그램의 크기가 70이면 불가)

** 홀 : 할당 가능한 비어 있는 메모리 공간

**불연속 할당**

- 현대 운영체제가 쓰는 방법으로 페이징 기법 존재
- 메모리를 동일한 크기의 페이지(보통 4kB)로 나누고 프로그램마다 페이지 테이블을 두어 이를 통해 메모리에 프로그램 할당

페이징

- 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스 할당
- 홀의 크기가 균일하지 않은 문제가 없어지나 주소 변환 복잡해짐

세그멘테이션

- 페이지 단위가 아닌 의미 단위인 세그먼트(segment)로 나누는 방식
- 프로세스를 이루는 메모리는 코드 영역, 데이터 영역, 스택 영역, 힙 영역으로 나뉘는데, 코드와 데이터로 나누거나 코드 내의 작은 함수를 세그먼트로 놓고 나눌  수 도 있음
- 공유와 보안 측면에서 장점을 가지나 홀 크기가 균일하지 않은 단점 존재

페이지드 세그멘테이션

- 프로그램을 의미 단위인 세그먼트로 나눠 공유나 보안 측면에 강점을 둠
- 임의의 길이가 아닌 동일 크기의 페이지 단위로 나누는 것을 의미

### 페이지 교체 알고리즘

- 메모리는 한정되어 있으므로 스와핑 자주 발생
- 스와핑이 덜 발생하도록 설계되어야 하며 이는 페이지 교체 알고리즘을 기반으로 스와핑 발생

**오프라인 알고리즘**

- 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘 (가장 좋은 방법)
- 허나 미래에 사용되는 프로세스를 알 수 없기에 사용 불가
- 사용 불가하지만 가장 좋기 때문에 다른 알고리즘과의 성능 비교에 대한 상한 기준 제공

**FIFO**

- First In First Out
- 가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 방법

**LRU**

- Least Recentle Used
- 참조가 가장 오래된 페이지 변경
- 오래된 것을 파악하기 위해 각 페이지마다 계수기, 스택을 두어야 하는 문제점 존재

![Untitled](WEEK05_%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%2087414011882c4e25b7d6cd1b5733bd46/Untitled%206.png)

- LRU를 프로그래밍으로 구현 시 보통 두개의 자료 구조로 구현 (해시 테이블과 이중 연결 리스트)
- 해시 테이블 : 이중 연결 리스트에서 빠르게 찾을 때 사용, 이중 연결 리스트 : 한정된 메모리 표시

NUR

- Not Used Recently
- LRU에서 발전한 알고리즘으로, clock 알고리즘이라고도 함

![Untitled](WEEK05_%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%2087414011882c4e25b7d6cd1b5733bd46/Untitled%207.png)

- 먼저 0과 1을 가진 비트를 두고, 1은 최근에 참조, 0은 참조되지 않음을 의미
- 시계 방향으로 돌면서 0을 찾고 그 순간 해당 프로세스 교체 및 해당 부분을 1로 변경

**LFU**

- Least Frequently Used
- 가장 참조 횟수가 적은 페이지 교체 (많이 사용되지 않은 것 교체)