# 프로세스와 스레드 & CPU 스케줄링 알고리즘

작성일시: 2023년 9월 12일 오후 2:01
최종 편집 일시: 2023년 9월 12일 오후 2:50

# 3.3 프로세스와 스레드

프로세스

: 컴퓨터에서 실행되고 있는 프로그램을 말하며 CPU 스케줄링의 대상이 되는 작업이라는 용어와 같은 의미.

- 프로그램이 메모리에 올라가 인스턴스화 된 것

스레드 

: 프로세스 내 작업의 흐름을 지칭한다.

**3.3.1 프로세스와 컴파일 과정**

컴파일 과정 

![DC936A34-B57C-480B-A53A-41A4E1AC32BA.jpeg](%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20&%20CPU%20%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A6%E1%84%8C%E1%85%AE%E1%86%AF%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%203201ce77311c432aa64ccfadfa099955/DC936A34-B57C-480B-A53A-41A4E1AC32BA.jpeg)

전처리 

: 소스 코드의 주석을 제거하고 헤더 파일을 병합하여 매크로를 치환한다.

컴파일러

: 오류 처리, 코드 최적화 작업을 하며 어셈블리어로 변환한다.

어셈블러

: 목적 코드로 변환됨. 확장자는 운영체제마다 다름. 

정적 라이브러리

: 프로그램 빌드 시 라이브러리가 제공하는 모든 코드를 실행 파일에 넣는 방식으로 라이브러리를 쓰는 방법.

- 외부 의존도가 낮음.
- 코드 중복 등 메모리 효율성이 떨어짐.

동적라이브러리

: 프로그램 실행 시 필요할 때만 DLL이라는 함수 정보를 통해 참조하여 라이브러리를 쓰는 방법.

- 메모리 효율성이 좋음.
- 외부 의존도가 높음.

**3.3.2  프로세스의 상태**

![696D2FE2-3E05-443B-BEB9-1E517C4A808B.jpeg](%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20&%20CPU%20%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A6%E1%84%8C%E1%85%AE%E1%86%AF%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%203201ce77311c432aa64ccfadfa099955/696D2FE2-3E05-443B-BEB9-1E517C4A808B.jpeg)

생성 상태

: 프로세스가 생성된 상태.

fork() / exec() 함수를 통해 생성.

⇒ 이때, PCB가 할당됨.

fork() 함수

: 부모 프로세스의 주소 공간을 그대로 복사하여 새로운 자식 프로세스 생성. 

- 주소 공간만 복사할 뿐임. (부모 프로세스의 비동기 작업 등을 상속하지는 않음)

exec() 함수

: 새롭게 프로세스를 생성하는 함수.

대기 상태

: 메모리 공간이 충분하면 메모리를 할당받고, 아니면 아닌 상태로 대기. 

대기 중단 상태

: 메모리 부족으로 일시 중단된 상태.

실행 상태

: CPU 소유권과 메모리를 할당받고 인스트럭션을 수행 중인 상태. (= CPU 부스트가 일어났다)

일시 중단 상태

: 대기 중단과 유사. 중단된 상태에서 프로세스가 실행되려고 했지만 메모리 부족으로 일시 중단. 

종료 상태

: 메모리와 CPU 소유권을 모두 놓고 가는 상태. 

- 자연스러운 종료.
- 비자발적 종료 : 부모 프로세스가 자식 프로세스를 강제시키는 종료

**3.3.3 프로세스의 메모리 구조**

동적 영역 

: 런타임 단계에서 메모리를 할당받는 것.

- 스택 , 힙

정적 영역 

: 컴파일 단계에서 메모리를 할당하는 것.

- 데이터 영역, 코드 영역

**3.3.4 PCB**

PCB

: 운영체제에서 프로세스에 대한 메타데이터를 저장한 ‘데이터’ (= 프로세스 제어블록)

- 프로세스의 중요한 정보를 포함하고 있어 커널 스택의 가장 앞부분에서 관리된다. (일반 사용자 접근 제한)

*메타데이터

: 데이터에 관한 구조화된 데이터.

: 데이터를 설명하는 작은 데이터. 

- 대량의 정보 가운데 찾고 있는 정보를 효율적으로 찾아내서 이용하기 위해 일정한 규칙에 따라 콘텐츠에 부여되는 데이터.

PCB 구조

- 프로세스 스케줄링 상태
- 프로세스 ID
- 프로세스 권한
- 프로그램 카운터
- CPU 레지스터
- CPU 스케줄링 정보
- 계정 정보
- I/O 상태 정보

컨텍스트 스위칭

: PCB를 교환하는 과정.

**3.3.5 멀티프로세싱**

멀티프로세싱

: 여러 개의 프로세스를 통해 동시에 두 가지 이상의 일을 수행 가능.

- 하나 이상의 일을 병렬로 처리 가능.
- 신뢰성 높음.

웹 브라우저

: 멀티프로세스 구조. 

- 브라우저 프로세스
- 렌더러 프로세스
- 플러그인 프로세스
- GPU 프로세스

ICP

: 프로셋끼리 데이터를 주고받고 공유 데이터를 관리하는 메커니즘. 

: 메모리가 완전히 공유되는 스레드보다 속도가 떨어짐.

- 공유 메모리
- 파일
- 소켓
- 익명 파이프
- 명명 파이프
- 메시지 큐

**3.3.6 스레드와 멀티스레딩**

![8CA059D6-E734-4B16-AD2B-DC8653F43D06.jpeg](%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20&%20CPU%20%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A6%E1%84%8C%E1%85%AE%E1%86%AF%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%203201ce77311c432aa64ccfadfa099955/8CA059D6-E734-4B16-AD2B-DC8653F43D06.jpeg)

멀티 스레딩

: 프로세스 내 작업을 멀티스레드로 처리하는 기법.

- 스레드끼리 서로 자원을 공유. (= 효율성이 높음)
- 동시성
- 스레드로 이루어져 있는 프로세스에는 영향을 줄 수도 있음.

*동시성

: 서로 독립적인 작업들을 작은 단위로 나누고 동시에 실행되는 것처럼 보여주는 것.

**3.3.7 공유 자원과 임계 영역**

공유 자원

: 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 자원이나 변수 등을 의미한다.

- 경쟁 상태 : 공유 자원을 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황.

임계 영역

: 둘 이상의 프로세스, 스레드가 공유 자원에 접근할 때  결과가 달라지는 코드 영역.

⇒ 상호 배제, 한정 대기, 융통성 모두 만족 

- 뮤텍스 - 잠금 메커니즘
- 세마포어 (일반화된 뮤텍스) - 신호 메커니즘
    - 바이너리 세마포어 : 0과 1 만 값으로 가짐.
    - 카운팅 세마포어 : 여러 개의 값을 가질 수 있음.
- 모니터

*상호 배제 - 한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없음.

*한정 대기 - 특정 프로세스가 영원히 임계 영역에 들어가지 못하면 안 됨.

*융통성 - 한 프로세스가 다른 프로세스의 일을 방해해서는 안 됨.

**3.3.8 교착 상태**

: 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태. 

원인 

- 상호 배제
- 점유 대기
- 비선점
- 환형 대기

해결 방법

1. 자원 할당 시 애초에 조건 성립이 되지 않도록 설계.
2. ‘은행원 알고리즘’ 사용.
3. 사이클이 있는지 찾아보고 이에 관련된 프로세스를 하나씩 지움.
4. 사용자가 작업을 종료한다. ⇒ 현대 운영체제는 이 방법 채택. 

---

# 3.4 CPU 스케줄링 알고리즘

![D8D8A4EA-8C4F-449A-99EE-C324778261C2.jpeg](%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20&%20CPU%20%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A6%E1%84%8C%E1%85%AE%E1%86%AF%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%203201ce77311c432aa64ccfadfa099955/D8D8A4EA-8C4F-449A-99EE-C324778261C2.jpeg)

**3.4.1 비선점형 방식**

: 프로세스가 스스로 CPU 소유권을 포기하는 방식. 강제로 프로세스를 중지하지 않음.

- FCFS
- SJF : 실행 시간이 가장 짧은 프로세스를 가장 먼저 실행하는 알고리즘.
- 우선순위

3.4.2 선점형 방식

⇒ 현대 운영체제가 쓰는 방식 

:  사용 중인 프로세스를 알고리즘에 의해 중단시켜 버리고, 강제로 다른 프로세스에 CPU 소유권을 할당.

- 라운드 로빈 : 우선순위 스케줄링. 할당 시간 내에 끝나지 않으면 다시 준비 큐의 뒤로 가는 알고리즘.
- SRF : 중간에 실행 시간이 더 짧은 작업이 들어오면 수행하던 프로세스를 중지하고 해당 프로세스를 수행.
- 다단계 큐