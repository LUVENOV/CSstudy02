## 3.3 프로세스와 스레드

- 프로그램 : 특정 작업을 실행할 수 있도록 해주는 코드의 집합
- 프로세스 : 메모리에 올라가서 **인스턴스화**된 프로그램
  - CPU 스케줄링의 대상
- 스레드 : 프로세스 내의 작업 흐름
  - 프로세스는 최소 1개의 스레드로 이루어져 있다

### 3.3.1 프로세스와 컴파일 과정

#### 프로그램의 인스턴스화

- 컴파일 : 컴파일러를 통해 기계어로 번역되어 실행될 수 있는 파일로 전환
  _ 여기서 인터프리트 언어와는 별개
  _ C 언어를 예시로 설명
  _ 전처리 : 코드의 주석을 제거하고 #include 등 헤더 파일을 병합하여 매크로를 치환
  _ 컴파일러 : 오류 처리, 코드 최적화 작업을 하여 어셈블리어로 변환
  _ 어셈블러 : 어셈블리어를 목적 코드(object code) 로 변환
  _ 확장자 : 리눅스 기준 .o
  _ 링커 : 프로그램 내에 있는 라이브러리 함수 및 다른 파일들의 목적코드와 결합하여 실행파일을 만듬
  _ 확장자 : .exe, .out
  <br>
- 정적 라이브러리와 동적 라이브러리
  - 정적 라이브러리 : 프로그램 빌드시 라이브러리가 제공하는 모든 코일을 실행 파일에 넣는 방식
    - 장점 : 시스템 환경 외부 의존도가 낮음
    - 단점 : 코드 중복 등 메모리 효율성 감소
  - 동적 라이브러리 : 프로그램 실행시에 필요할 때만 함수 정보를 참조하여 라이브러리 사용하는 방식 (DDL)
    - 장단점은 정적 라이브러리의 반대

### 3.3.2 프로세스의 상태

##### 1. 생성상태

CPU에 의해 프로세스가 할당된 상태

- fork() , exec() 함수를 통해 생성
  - fork() : 부모 프로세스의 주소 공간을 그대로 복사하여 새로운 자식 프로세스를 생성하는 함수
    - 주소공간만 복사할 뿐 부모 프로세스의 비동기 작업등을 상속하지 않음
  - exec() : 아예 새로운 프로세스를 생성하는 함수
    - 메모리 공간을 새로운 프로그램으로 덮어씌움
- PCB 할당

##### 2. 대기상태

CPU 스케줄러로 부터 CPU 소유권이 넘어가기를 기다리는 상태 (당장이라도 실행될 수 있는 상태)

- 메모리 공간이 충분하면 메모리를 할당받고 아니면 대기하고 있음

##### 3. 대기 중단 상태

메모리 부족으로 일시 중단된 상태

##### 4. 실행 상태

CPU 소유권이 메모리를 할당 받고 인스트럭션을 수행중인 상태

- CPU Burst라고 표현하기도 함
- Burst : 어떠한 작업이 집중적으로 이루어지는 구간
  - **프로세스는 IO Burst와 CPU Burst의 연속이라고 할 수 있다!**

##### 5. 중단 상태

어떤 이벤트가 발생하여 프로세스가 차단된 상태

- 대표적으로 I/O 디바이스에 의한 인터럽트 등이 있음
  (입출력 장치 등을 사용하면 느리기 때문에 CPU 할당 대기, 끝나면 준비상태로 변경)

##### 6. 일시 중단 상태

대기 중단과 유사한 상태로 중단된 상태에서 프로세스가 실행되려고 했으나 메모리 부족으로 일시 중단된 상태 (?)

##### 7. 종료 상태

메모리와 CPU 소유권을 모두 놓고 가는 상태?

- 작업이 모두 실행되어 자연스럽게 종료되는 경우
- 강제 종료되는 경우
  - 자식 프로세스에 할당된 자원의 한계치를 넘어서는 경우 강제 종료
  - 부모 프로세스가 종료될 때 강제 종료
  - 사용자가 process.kill 명령어로 강제 종료

### 3.3.3 프로세스의 메모리 구조

- 위에서 부터 기술
- 동적 영역
  - 스택 : 위 주소부터 할당
  - 힙 : 아래 주소부터 할당
- 정적 영역
  - 데이터영역 (BSS Segment, Data Segment)
  - 코드 영역

#### 스택 영역

- 지역변수, 매개변수, 함수가 저장되는 영역
- 컴파일시 크기 결정
- 동적 영역 : 함수가 함수를 재귀적으로 호출하면서 동적으로 크기가 늘어날 수 있음
  - 이 때 힙과 스택 메모리 영역이 겹치지 않도록 사이 공간을 비워둠

#### 힙 영역

- 벡터와 같은 동적 배열 할당되는 영역
- 런타임시 크기 결정
- 동적 영역
- Garbage Collection

#### 데이터 영역

- 전역변수, 정적변수 저장
- BSS Segment : 초기화 되지 않은 변수가 0으로 초기화되어 저장
- Data Segment : 0이 아닌 다른 값으로 할당된 변수들이 저장
- 정적 영역

#### 코드 영역

- 프로그램에 내장된 소스코드가 들어가있는 영역
- 수정 불가능한 기계어로 저장 (READ ONLY)
- 정적 영역

### 3.3.4 PCB

#### PCB (Process Control Block) : OS에서 프로세스에 대한 메타데이터를 저장한 데이터

- 프로세스 생성시 OS에 의해 생성됨
- 이 때 프로세스 주소값
- 일반 사용자가 접근하지 못하도록 **커널 스택 가장 앞 부분에서 관리**
- PCB가 관리하는 메타데이터
  (1) **OS가 관리상 사용하는 정보 :** Process state, Process ID, scheduling information proirty
  (2) **CPU 수행 관련 하드웨어 값 :** Program counter, resisters
  (3) **메모리 관련 :** Code,data,stack 위치정보
  (4) **파일 관련 :** Open file descriptors
  (아래서 다시 정리)

##### PCB 구조

- 프로세스 스케줄링 상태 : "준비", "일시중단", "생성", "사용중" 등
- 프로세스 ID (PID) : 틀정 프로세스를 식별하기 위한 고유정보
  - 자신과 자신의 자식 프로세스의 PID를 가ㅣ고 있음
- 프로세스 권한 :
- **프로그램 카운터 : 프로로세스에서 실행해야 할 다음 명령어의 주소에 대한 포인터**
- CPU 레지스터 : 프로세스를 실행하기 위해 저장해야 할 레지스터에 대한 정보
- CPU 스케줄링 정보 : 어떤 순서로 CPU를 할당 받을지, 스케줄러에 의해 중단된 시간 등에 대한 정보
- 계정 정보 : 프로세스 실행에 사용된 CPU 사용량, 실행 유저 정보 등
- I/O 정보 : 프로세스에 할당된 I/O 디바이스 목록

#### Context Switching (문맥교환)

- PCB를 교환하는 과정
- 문맥 (Context) : A 프로세스에서 B 프로세스로 바뀔 때 A와 B의 중간 정보
  - 프로그램 카운터 등 레지스터 값, 메모리 정보, 열었던 파일, 사용한 입출력 장치 등
  - A의 중간정보 Back UP
  - B의 중간정보 복구
  - 캐시 미스 비용 발생

<br>
* 사용자 프로세스에서 OS로 CPU 권한이 넘어가는 것은 (예시로 interrupt) context switching이 아님
but 커널모드 후 프로세스 A로 돌아오지 않고 B로 넘어가면 여기서 context switching 발생
interrupt의 경우에도 약간의 문맥을 저장해야하나 문맥교환인의 경우 overhead가 더 큼 (cache memory flush 때문)

##### 캐시 미스 (비용)

: 문맥교환이 일어날 때 프로세스가 가지고 있는 메모리 주소가 그대로 있게 되면 잘못된 주소 변환이 생기기 때문에 캐시 클리어 필요 (이 때 캐시 미스 발생)

##### 스레드에서의 문맥교환

**: 스레드에서는 스택 영역을 제외한 모든 메모리를 공유하기 때문에 비용이 더 적다!**

### 3.3.5 멀티 프로세싱

- 멀티 프로세싱 : 여러개의 프로세스를 통해 동시에 두 가지 이상의 일을 수행하는 것
- 장점
  - 일을 병렬로 처리
  - 높은 신뢰성 : 프로세스 중 일부에 문제 발생되더라도 다른 프로세스 이용하여 처리 가능

#### 웹 브라우저

- 브라우저 프로세스 : 네트워크 요청이나 파일 접근과 같은 권한을 담당
  - 예지 : 주소 표시줄, 북마크 막대, 뒤로가기 버튼, 앞으로가기 버튼
- 렌더러 프로세스 : 웹사이트가 "보이는" 부분의 모든 것 제어
- 플러그인 프로세스
- GPU 프로세스

#### IPC (Inter Process Communication)

- 프로세스끼리 데이터를 주고 받고 공유 데이터를 관리하는 메커니즘

- 예시
  - 클라이언트와 서버
- 특징
  - 메모리가 완전히 공유되는 스레드보다 속도가 떨어짐

##### 공유 메모리

- 여러 프로세스에 동일한 메모리 블록에 대한 접근권한이 부여되어 프로세스가 서로 통신할 수 있도록 공유버퍼를 생성하는 것
- 기본적으로는 각 프로세스의 메모리를 다른 프로세스에서 접근할 수 없으나 공유메모리로 이를 가능케 할 수 있음
- 장점
  - 불필요한 데이터 복사의 오버헤드가 없어 속도가 빠름
- 단점
  - 동기화 필요

##### 파일

- 디스크에 저장된 데이터 or 파일 서버레서 제공한 데이터
- 이를 기반으로 프로세스간 통신

##### 소켓

- 동일한 컴퓨터의 다른 프로세스나 네트워크의 다른 컴퓨터로 네트워크 인터페이스를 통해 전송하는 데이터
- 대표적인 예시로 TCP, UDP
- 프로그램이 네트워크를 통해 서로 통신을 수행할 수 있도록 양쪽에 생성되는 링크의 단자
- ⇒ 서로 다른 프로세스끼리 데이터 전달이 가능하다 !

##### 익명 파이프

- FIFO 방식으로 읽히는 임시공간인 파이프를 기반으로 데이터를 주고 받는 방식
- **단방향 방식**의 읽기 전용, 쓰기 전용 파이프 만들어 작동
- 부모 자식 프로세스 간에서만 사용 가능 (다른 네트워크 사용 불가)

##### 명명된 파이프

- 파이프 서버와 하나 이상의 파이프 클라이언트 간의 통신을 위한 명명된 단방향 or 이중 파이프
- 클라이언트 / 서버 간 통신을 위한 별도 파이프 제공하며 여러 파이프 동시에 사용 가능
- 컴퓨터 프로세스 끼리 또는 다른 네트워크 상의 컴퓨터와 통신 가능

##### 메세지 큐

- 메세지를 큐 데이터 구조 형태로 관리
- 커널의 전역변수 형태 등으로 관리
- 다른 IPC 방식에 비해 매우 직관적이고 간단하다는 장점
- 공유 메모리 통해 IPC 구현 시 쓰기 및 읽기 빈도가 높으면 동기화 때문에 구현이 매우 복잡해질 수 있음, 이 때 메시지 큐 사용하기도

### 3.3.6 스레드와 멀티 스레딩

##### 스레드

- 프로세스의 실행 가능한 가장 작은 단위
- **같은 프로세스의 스레드는 코드, 데이터, 힙 공유 // 스택 및 다른 영역은 각각 생성**

##### 멀티 스레딩

- 프로세스 내 작업을 여러개의 스레드로 처리하는 기법
- 장점
  - 스레드 끼리 서로 자원을 공유하기 때문에 효율성이 높음
  - 새 프로세스를 생성하는 것보다 새로운 스레드를 생성하는 것이 훨씬 적은 리소스를 소비
  - 한 스레드가 중단되어도 다른 스레드는 실행 상태일 수 있기 때문에 빠른 처리, 응답
  - 동시성 : 독립적인 작업물들을 작은 단위로 나누어 동시에 실행되는 것처럼 보여주는 것
- 단점
  - 한 스레드에 문제가 생기면 다른 스레드에서도 영향을 끼칠 수 있음
- 예시
  - 웹 브라우저의 렌더러 프로세스
    - 메인 스레드
    - 워커 스레드
    - 컴포지터 스레드
    - 레스터 스레드

### 3.3.7 공유자원과 임계 영역

##### 공유 자원 (shared resource)

- 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 자원 및 변수
- 대포적으로 모니터, 프린터, 메모리, 파일, 데이터 등
- 경쟁 상태 (race condition) : 공유자원을 두개 이상의 프로세스가 동시에 읽거나 쓰는 상황
  - 동시에 접근을 시도할 때 접근 타이밍이나 순서에 따라 결과값에 영향을 줄 수 있음

#### 임계 영역 (critical section)

- 둘 이상의 프로세스, 스레드가 공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 코드 영역
- 해결 방법 0. 스핀 락
  1. 뮤텍스
  2. 세마포어
  3. 모니터
- 해결 방안의 조건

  - 상호 배제 (Mutual Exclusion) : 한 프로세스가 공유 자원을 사용하고 있으면, 다른 프로세스는 해당 공유자원에 접근할 수 없도록 해야 함
  - 한정 대기 : 어떠한 프로세스도 임계영역 진입 요구 시 무한히 대기하지 않아야 한다.
  - 융통성 : 임계 영역에 들어있는 프로세스가 없을 경우에, 프로세스는 진입할 수 있어야 한다. / 한 프로세스가 다른 프로세스의 일을 방해해서는 안된다.

  ##### 0. 스핀 락

  - 어떠한 프로세스가 반복문을 돌면서 임계영역에 들어갈 수 있을지 계속 확인하는 방법
  - 단점 : CPU 낭비
  - 사용하는 경우 : 멀티 코어 환경에서 임계 영역에서의 작업이 문맥교환보다 더 빨리 끝난다면 뮤텍스보다 유리하다
    - 이유 : 문맥교환에 의한 비용이 더 크며 스핀 락에서는 문맥 교환이 적다.

  ##### 1. 뮤텍스

  - 프로세스나 스레드가 공유자원 lock()을 통해 잠금을 설정하고 잠근 후에는 unlock()을 통해 잠금해제하는 객체
  - 프로세스가 임계 지점에 도달하면 다른 프로세스들은 접근하지 못하고 잠에 듬, 작업을 완료한 프로세스는 다른 프로세스들을 깨움
  - 여기서 lock이라는 변수와 이 lock이라는 공유자원 동시 접근을 방지하기 위한 추가 값이 있다
  - 뮤텍스와 세마포어의 차이?
    - **뮤텍스는 락을 가진 자만이 락을 해제할 수 있다. (세마포어와 다른점)**

  ##### 2. 세마포어

  - 일반화된 뮤텍스
  - wait() : 자신의 차례가 올 때가지 기다리는 함수 (잠에 드는 함수)
  - signal() : 다음 프로세스로 순서를 넘겨주는 함수 (깨워주는 함수)
  - **wait(), signal()을 통해 프로세스간 작업 우선순서를 정해줄 수 있다 (A 프로세스의 a 작업이 끝나야 B 프로세스의 b 작업이 실행될 수 있도록 할 수 있다.)**
  - 세마포어에는 조건변수가 없으며 여러 프로세스가 동시에 접근할 수 있으나 세마포어 값은 한번에 한 프로세스나 스레드만 바꿀 수 있다.
  - 종류
    - 바이너리 세마포어 : 0, 1 두 가지 값만 가질 수 있는 세마포어
      - 뮤텍스와 다른 점?
        - 뮤텍스 : 잠금을 기반으로 상호배제가 일어나는 잠금 메커니즘, 락을 가진 프로세스만 락을 해제할 수 있음
        - 세마포어 : 신호를 기반으로 상호배제가 일어나는 신호 메커니즘, 누가 락을 해제할 지 알 수 없음
    - 카운팅 세마포어 : 여러개의 값을 가질 수 있는 세마포어로 여러 자원에 대한 접근 제어할 때 사용
      - ex) 자리가 3개인 화장실!

##### 3. 모니터

- 둘 이상의 스레드가 프로세스가 공유자원에 안전하게 접근할 수 있도록 공유자원을 숨기고 해당 접근에 대해 인터페이스만 제공
- 모니터 큐를 통해 공유 자원에 대한 작업을 순차적으로 처리
- 세마포어와의 차이
  - 모니터 : 보다 구현하기 쉬우며 자동적으로 상호 배제
  - 세마포어 : 상호 배제를 명시적으로 구현해야

### 3.3.8 교착상태 (deadlock)

- 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태

##### 교착상태의 원인

1. 상호배제 (Mutual Exclusion): 한 프로세스가 자원을 독점하는 경우
2. 점유 대기 (Hold & Wait): 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하는 경우
3. 비선점 (No preemption): 다른 프로세스의 자원을 강제적으로 가져올 수 없음으로
4. 순환대기 (Circular Wait): 서로가 서로의 자원을 요구하는 상황

##### 교착 상태의 해결

: 위 4가지 중 1가지만 성립하지 않으면 DeadLock은 일어나지 않는다

1. 상호배제는 필수불가결
2. 비선점 : CPU, memory 같이 state를 쉽게 save하고 restore할 수 있는 자원에서 사용 가능
3. **Hold & Wait :** 프로세스가 자원을 요청할 때 다른 어떠한 자원도 가지고 있지 않으면 된다.
   1. 프로세스 시작시 모든 필요한 자원을 할당받게 함 >> 비효율\*
   2. 자원이 필요할 때 보유 자원을 모두 놓고 다시 요청하는 법\*
4. **Circular Wait (순환대기) :** 모든 자원 유형에 할당 순서를 정하고 위 순서대로만 자원 할당
   1,3,5번 자원을 오름차순 순서대로 획득 가능하게 하면 됨

##### 교착 상태 해결

1. 프로세스가 시작될 때 프로세스가 평생 쓸 자원일 미리 동적으로 조사하여 안전한 경우에만 할당 (은행원 알고리즘)
2. 교착 상태가 발생한 사이클을 찾고 이에 관련된 프로세스를 한개 씩 지움
3. 교착상태를 해결하는데 드는 비용이 더 크기 때문에 그냥 신경쓰지 않는다 (현대의 운영체제)
