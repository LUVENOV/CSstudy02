## 4.6 조인의 종류

- join : 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것
  - MySQL : JOIN
  - MongoDB : lookup (관계형 DB에 비해 성능이 떨어지는 것으로 알려져있어 사용을 지양해야)
  - 따라서 여러 테이블을 조인하는 경우가 많을 경우 MongoDB 보다는 관계형 DB를 쓰는 것이 좋다

#### 4.6.1 내부 조인 (교집합)

- 왼쪽 테이블과 오른쪽 테이블의 두행이 모두 일치하는 행이 있는 부분만 표기

```
SELECT * FROM TableA A
INNER JOIN TableB B ON
A.key = B.key
```

#### 4.6.2 왼쪽 조인 (왼쪽 집합)

- 왼쪽 테이블의 모든 행이 결과 테이블에 표기
- 테이블 B의 일치하는 부분의 레코드와 함께 테이블 A를 기준으로 완전한 레코드 집합을 생성
- 만약 테이블 B에 일치하는 항목이 없으면 해당 값은 null이 됨

```
SELECT * FROM TableA A
LEFT JOIN TableB B ON
A.key = B.key
```

#### 4.6.3 오른쪽 조인 (오른쪽 집합)

- 오른쪽 테이블의 모든 행이 결과 테이블에 표기
- 테이블 A의 일치하는 부분의 레코드와 함께 테이블 B를 기준으로 완전한 레코드 집합을 생성
- 만약 테이블 A에 일치하는 항목이 없으면 해당 값은 null이 됨

```
SELECT * FROM TableA A
RIGHT JOIN TableB B ON
A.key = B.key
```

#### 4.6.4 합집합 조인 (합집합)

- 두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기
- 양쪽 테이블에서 일치하는 레코드와 함께 테이블 A와 B의 모든 레코드 집합을 생성
- 이 때 일치하는 항목이 없으면 누락된 쪽의 값이 null을 포함하여 출력

```
SELECT * FROM TableA A
FULL OUTER JOIN TableB B ON
A.key = B.key
```

## 4.7 조인의 원리

#### 4.7.1 중첩 루프 조인 (NLJ, Nested Loop Join)

- 중첩 for 문과 같은 원리로 조건에 맞는 조인을 하는 방법
- 랜덤 접근에 대한 비용이 많이 증가하므로 대용량의 테이블에서는 사용하지 않음
- 블록 중첩루프 조인 (BNL, Block Nested Loop) : 조인할 테이블을 작은 블록으로 나눠서 블록 하나씩 조인

#### 4.7.2 정렬 병합 조인

- 각각의 테이블을 조인할 필드 기준으로 정렬하고, 정렬이 끝난 후 조인 작업을 수행하는 조인
- 조인할 때 쓸 적절한 인덱스가 없고 대용량의 테이블들을 조인하고 조인 조건으로 <,> 등 범위 비교연산자가 있을 때 씀

#### 4.7.3 해시 조인

- 해시 테이블을 기반으로 하는 조인
- 두 개의 테이블을 조인한다고 했을 때 하나의 테이블이 메모리에 온전히 들어간다면, 보통 중첩 루프 조인보다 효율적
- 동등(=) 조인에서만 사용 가능
- MySQL 의 해시 조인 단계는 빌드 단계와 프로브 단계로 나눠짐

##### 빌드 단계

- 입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계
- 바이트가 제일 작은 테이블을 기반으로 빌드함
- 조인에 사용되는 필드가 해시 테이블의 키로 사용

##### 프로브 단계

- 레코드 읽기
- 해시테이블을 기반으로 일치하는 레코드를 찾아 반환
- 이를 통해 각 테이블을 한번씩만 읽게 되어 중첩하여 두 개의 테이블을 읽는 중첩 루프 조인보다 성능이 보통 더 좋음
- 사용 가능한 메모리 양은 시스템 변수 join_buffer_size에 의해 제어, 런타임시 조정 가능
