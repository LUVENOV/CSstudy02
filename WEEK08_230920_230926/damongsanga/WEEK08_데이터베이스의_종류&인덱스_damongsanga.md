## 4.4 데이터베이스의 종류

### 4.4.1 관계형 데이터베이스 (RDBMS)

- 관계형 데이터베이스 (RDBMS)란 행과 열을 가지는 표(테이블) 형식 데이터를 저장하는 형태의 데이터베이스
- SQL이라는 언어를 써서 조작
- 표준 SQL을 지키지만 각가의 제품의 특화시킨 SQL을 사용
  - 오라클 : PL/SQL
  - SQL Server : T-SQL,
  - MySQL : SQL
- 변화하는 업무나 데이터 구조에 대한 유연성이 좋아 유지 관리가 용이
- 특징
  - 무결성
  - 중복 허용 X
  - Scale-up

##### MySQL (by Oracle)

- 가장 널리 쓰이는 DB
- C, C++로 구성됨
- 대용량 데이터베이스를 위해 설계
- 기능
  - MyISAM 인덱스 압축 기술
  - B-Tree 기반 인덱스
  - 스레드 기반 메모리 할당
  - 빠른 조인
  - 최대 64개의 인덱스
  - 롤백, 커밋, 이중암호 지원 보안

##### PostgreSQL

- VACCUM : 디스크 조각이 차지하는 영역을 회수할 수 있는 장치
- 최대 테이블 크기 32TB
- JSON 호환
- 지정시간 복구, 로깅, 접근 제어, 중첩된 트랜잭션, 백업 가능

### 4.4.2 NoSQL 데이터베이스

- Not Only SQL
- 스키마 X, Join 연산 X
- 수평적으로 확장 가능
- 비정형 데이터 처리 유리
- 스키마 변경 불가능하여 데이터 값에 문제가 발생하면 감지하기 어려움
- 특정
  - 유연성
  - 중복 허용
  - Scale-out
  - 언제든지 접근 가능
  - soft-state : 노드의 상태는 외부에서 전송된 정보를 통해 결정되며 특정 시점에서는 데이터의 일관성이 보장되지 않는다
  - 일정 시간이 지나면 데이터의 일관성이 보장

##### MongoDB

- JSON을 통해 데이터 접근
- BSON(Binary JSON) 형태로 데이터 저장
- 기본 스토리지 엔진 : 와이어드타이거 엔진
  - 키-밸류 데이터 모델에서 확장된 도큐먼트 기반의 DB
- 확장성이 우수, 빅데이터를 저장할 때 성능이 좋음
- 고가요용성, 샤딩, 레플리카셋 지원
- 스키마를 정해놓지 않고 데이터 삽입 가능
  - 다양한 도메인의 데이터 베이스를 기반으로 분석하거나 로깅 가능
- **ObjectID** : 도큐먼트 생성할 때마다 다른 컬렉션에서 중복되기 힘든 유니크 한 값
  - 기본키
  - 타임스탬프(4byte), 랜덤값(4byte), 카운터(3byte)

##### redis

- 인메모리 DB
- 키-밸류 데이터 모델 기반 DB
- 문자열이 기본 데이터 타입이며 512MB까지 저장 가능
- set, hash 지원
- pub/sub 기능
  - 채팅 시스템
  - 캐싱 계층 : 다른 DB 앞단에 두어 사용
  - 단순 키-밸류가 필요한 세션 정보 관리
  - 정렬된 셋 자료구조를 이용한 실시간 순위표 서비스 사용

<hr>

## 4.5 인덱스

### 4.5.1 인덱스의 필요성

- 인덱스(index)는 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블에 저장된 데이터의 검색 속도를 향상시키기 위한 자료구조

- 장점

  - 검색 대상 레코드의 범위를 줄여 검색 속도를 빠르게 할 수 있다 (시간적 이득)
  - 중복 데이터를 방지하거나 특정 컬럼의 유일성 보장 가능
  - ORDER BY, GROPUP BY, WHERE 절 등이 사용되는 작업 효율적으로 처리

- 단점

  - 인덱스 생성을 위한 시간 및 추가 공간 필요 (시간적, 공간적 손해)
  - C.U.D 작업시 인덱스 업데이트에 의한 성능 저하 발생 가능
  - 병행성 감소

- 언제 사용하면 좋을까?
  - 대량의 데이터 검색
  - 정렬된 결과 출력시
  - 조인 연산 수행시
  - 유니크한 값 가져올 시
  - 검색 빈도가 높을 시

### 4.5.2 B-트리

- HashTable

  - O(1)
  - 등호 연산에 특화되어있음으로 >, < 연산이 자주 사용되는 DB 검색에 해시 테이블은 적합하지 않음
  - 해시 충돌

- B-TREE

  - O(log N)
  - 루트노드, **브랜치 노드**, 리프 노드
  - 무조건 리프노드까지 가야 검색이 가능하나 링크드리스트라서 순차 검색에 용이함
  - 사용 이유

    1. 균형잡힌 트리 구조

    - 한 쪽으로만 트리가 쏠리는 현상 방지

    2. 대수확장성

    - 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것 (탐색 깊이에 비해 많은 데이터를 검색할 수 있음)

    3. 정렬 순서 보장

    - 특징
      - 자식 노드의 수는 부모 노드의 요소 개수 + 1개이다
      - 데이터는 정렬되어있어야 하며 중복되어서는 안된다
      - 노드는 key와 pointer로 구성

[B TREE 참조 자료](https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Tree)
[B+ TREE 참조 자료](https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Plus-Tree)

### 4.5.3 인덱스 만드는 법

##### MySQL

- 클러스터형 인덱스 (Primary Index)
  - 테이블당 1개 설정 가능
  - 검색 속도가 빠르고 사용 메모리가 적음 / 입력,수정,삭제는 더 느림
  - 주요 데이터를 인덱스로 사용, 인덱스 자체에 데이터가 포함되어있다고 볼 수 있음
  - 기본키로 만들 떄 : primary key
  - 기본키로 만들지 않을 때 : unique not null
- 세컨더리 인덱스 (Secondary Index)
  - 검색 속도가 느리고 사용 메모리가 많음
  - 데이터의 사본을 인덱스로 사용
  - 여러개 설정 가능 (최대 약 250개)
  - 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성하는 인덱스
  - create, index

##### MongoDB

- 도큐먼트 생성시 자동으로 ObjectID 형성, 해당 키가 기본키로 설정됨
- 세컨더리 키도 부가적으로 설정 가능

### 4.5.4 인덱스 최적화 기법

##### 1. 인덱스는 비용

- 읽기 비용 : 인덱스는 반드시 두 번 탐색하는 것
- 수정 비용 : 컬렉 션 수정시 인덱스도 수정 필요
  - B-Tree 에서 높이와 좌우를 균형있게 밸런싱, 분산하는데도 비용 소모

##### 2. 테스팅할 것

- 서비스별로 인덱스 최적화 기법은 상이하다
- elplain() 함수를 통해 인덳스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간 최소화해야

##### 3. 복합 인덱스는 같음, 정렬, 다중값, 카디널리티 순

- 여러 필드를 기반으로 조회 시 복합 인덱스 생성
- 이 인덱스 생성 순서에 따라 성능이 달라짐
- **이를 같음, 정렬, 다중 값, 카디널리티 순으로 생성해야 함**
  1. == , equal 과 같이 값이 같은지 확인하는 쿼리가 있다면 제일 먼저
  2. 정렬에 쓰는 필드면 그 다음
  3. 다중 값을 출력해야 하는 필드는 나중에 인덱스 설정 (ex : > or < )
  4. 카디널리티 (유니크한 값의 정도)가 높은 순서를 기반으로 인덱스 생성
  - 예시로 나이보다는 이름으로 인덱스를 먼저 생성해야함

[인덱스 관련 블로그](https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%EC%9D%B8%EB%8D%B1%EC%8A%A4index-%ED%95%B5%EC%8B%AC-%EC%84%A4%EA%B3%84-%EC%82%AC%EC%9A%A9-%EB%AC%B8%EB%B2%95-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC#%EC%9D%B8%EB%8D%B1%EC%8A%A4_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EC%A2%85%EB%A5%98)
