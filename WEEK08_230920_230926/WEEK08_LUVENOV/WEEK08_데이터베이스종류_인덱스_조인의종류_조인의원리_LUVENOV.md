# WEEK08_데이터베이스종류_인덱스_조인의종류_조인의원리

---

# 4.4 데이터베이스의 종류

---

## 4.4.1 관계형 데이터베이스(RDBMS)

- 행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스
- SQL 언어를 써서 조작 (MySQL, PostgreSQL, 오라클, SQL Server, MSSQL 등)
- 관계형 데이터베이스의 경우 표준 SQL은 지키기는 하지만 각각의 제품에 특화시킨 SQL 사용
    
    ex ) 오라클은 PL/SQL, SQL Server는 T-SQL, MySQL은 SQL 사용
    

### MySQL

- 대부분의 운영체제와 호환되며 현재 가장 많이 사용하는 데이터베이스
- C, C++로 만들어짐
- 제공 서비스
    - MyISAM 인덱스 압축 기술
    - B-트리 기반의 인덱스
    - 스레드 기반의 메모리 할당 시스템
    - 매우 빠른 조인
    - 최대 64개의 인덱스
- 대용량 데이터베이스를 위해 설계되어 있고 롤백, 커밋, 이중 암호 지원 보안 등의 기능 제공
- MySQL의 스토리지 엔진 아키텍쳐
    
    ![Untitled](WEEK08_%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8C%E1%85%A9%E1%86%BC%E1%84%85%E1%85%B2_%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3_%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%8B%E1%85%B4%E1%84%8C%E1%85%A9%E1%86%BC%E1%84%85%E1%85%B2_%E1%84%8C%E1%85%A9%E1%84%8B%204d7cb481048f49d7bd1807ebccafc514/Untitled.png)
    
- 스토리지 엔진 : 데이터베이스의 심장같은 역할을 하는 곳으로, 모듈식 아키텍처로 쉽게 스토리지 엔진을 바꿀 수 있으며 데이터 웨어하우징, 트랜잭션 처리, 고가용성 처리에 강점을 둠
- 스토리지 엔진 위에는 커넥터 API 및 서비스 계층을 통해 MySQL 데이터베이스와 상호 작용 가능
- 쿼리 캐시를 지원해서 입력된 쿼리 문에 대한 전체 결과 집합을 저장하기 때문에 사용자가 작성한 쿼리가 캐시에 있는 쿼리와 동일하면 서버는 단순히 구문 분석, 최적화 및 실행을 건너뛰고 캐시의 출력만 표시

### PostgreSQL

- 디스크 조각이 차지하는 영역을 회수할 수 있는 장치인 VACCUM이 특징
- 최대 테이블 크기는 32TB이며 SQL 뿐만 아니라 JSON을 이용해서 데이터 접근 가능
- 지정 시간에 복구하는 기능, 로깅, 접근 제어, 중첩된 트랜잭션, 백업 등 가능

## 4.4.2 NoSQL 데이터베이스

- NoSQL(Not only SQL)이라는 슬로건에서 생겨난 데이터베이스
- SQL을 사용하지 않는 데이터베이스 : MongoDB, redis

### MongoDB

- JSON을 통해 데이터에 접근 가능
- Binary JSON 형태(BSON)로 데이터가 저장
- 와이어드타이거 엔진이 기본 스토리지 엔진으로 장착된 키-값 데이터 모델에서 확장된 도큐먼트 기반의 데이터베이스
- 확장성이 뛰어나며 빅데이터 저장 시 성능이 좋음
- 고가용성, 샤딩, 레플리카셋 지원
- 스키마를 정해 놓지 않고 데이터 삽입이 가능하여 다양한 도메인의 데이터베이스를 기반으로 분석 및 로깅 등 구현 시 강점
- 도큐먼트 생성 시마다 다른 컬렉션에서 중복된 값을 지니기 힘든 유니크한 값이 ObjectID 생성
    - 기본키로 유닉스 시간 기반의 타임스탬프(4byte), 랜덤 값(5byte), 카운터(3byte)
        
        ![Untitled](WEEK08_%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8C%E1%85%A9%E1%86%BC%E1%84%85%E1%85%B2_%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3_%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%8B%E1%85%B4%E1%84%8C%E1%85%A9%E1%86%BC%E1%84%85%E1%85%B2_%E1%84%8C%E1%85%A9%E1%84%8B%204d7cb481048f49d7bd1807ebccafc514/Untitled%201.png)
        

### redis

- 인메모리 데이터베이스이자 키-값 데이터 모델 기반의 데이터베이스
- 기본적인 데이터 타입은 문자열(string)이며 최대 512MB까지 저장 가능
- 셋(set), hash(해쉬) 등 지원
- pub/sub 기능을 통해 채팅 시스템, 다른 데이터베이스 앞단에 두어 사용하는 캐싱 계층, 단순한 키-값이 필요한 세션 정보 관리, 정렬된 셋(sortted set) 자료구조를 이용한 실시간 순위표 서비스에 사용

# 4.5 인덱스

---

## 4.5.1 인덱스의 필요성

- 인덱스는 데이터를 빠르게 찾을 수 있는 하나의 장치
- 인덱스 설정을 통해 테이블 안에 내가 찾고자 하는 데이터를 빠르게 찾기 가능

## 4.5.2 B-트리

- 인덱스는 보통 B-트리 자료구조로 이루어짐
- 루트 노드, 리프 노드, 루트노드와 리프노드 사이의 브랜치 노드로 분류
    
    ex 1)
    

![Untitled](WEEK08_%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8C%E1%85%A9%E1%86%BC%E1%84%85%E1%85%B2_%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3_%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%8B%E1%85%B4%E1%84%8C%E1%85%A9%E1%86%BC%E1%84%85%E1%85%B2_%E1%84%8C%E1%85%A9%E1%84%8B%204d7cb481048f49d7bd1807ebccafc514/Untitled%202.png)

→ E 탐색 시 전체 테이블 탐색이 아닌 E가 있을 법한 리프 노드로 들어가서 탐색

ex 2)

![Untitled](WEEK08_%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8C%E1%85%A9%E1%86%BC%E1%84%85%E1%85%B2_%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3_%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%8B%E1%85%B4%E1%84%8C%E1%85%A9%E1%86%BC%E1%84%85%E1%85%B2_%E1%84%8C%E1%85%A9%E1%84%8B%204d7cb481048f49d7bd1807ebccafc514/Untitled%203.png)

→ 트리 탐색은 맨 위 루트 노드부터 탐색 시작하여 브랜치 노드를 거쳐 리프 노드까지 내려옴

→57보다 같거나 클 때까지 ≤를 기반으로 처음 루트 노드에서는 39, 83 이후 아래 노드로 내려와 46, 53, 57 등 정렬된 값을 기반으로 탐색해 마지막 리프 노드에 도달하여 57이 가리키는 데이터 포인터를 통해 결괏값 반환

### 인덱스가 효율적이 이유와 대수확장성

- 인덱스가 효율적인 이유 : 효율적인 단계를 거쳐 모든 요소에 접근 가능한 균형 잡힌 트리 구조와 트리 깊이의 대수확장성 때문
- **대수확장성** : 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것
    - 기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가
    - 실제 인덱스는 훨씬 더 효율적

![Untitled](WEEK08_%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8C%E1%85%A9%E1%86%BC%E1%84%85%E1%85%B2_%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3_%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%8B%E1%85%B4%E1%84%8C%E1%85%A9%E1%86%BC%E1%84%85%E1%85%B2_%E1%84%8C%E1%85%A9%E1%84%8B%204d7cb481048f49d7bd1807ebccafc514/Untitled%204.png)

## 4.5.3 인덱스 만드는 방법

- 데이터베이스마다 다름

### MySQL

- 클러스터형 인덱스와 세컨더리 인덱스가 있으며, 클러스터형 인덱스는 테이블 당 하나 설정 가능
- primary key 옵션을 기본키로 만들면 클러스터형 인덱스를 생성 가능하며, 기본키로 만들지 않고 unique not null 옵션을 붙이면 클러스터형 인덱스로 만들기 가능
- create index… 명령어를 기반으로 만들면 세컨더리 인덱스 생성 가능
- 하나의 인덱스만 생성할 것이라면 클러스터형 인덱스를 만드는 것이 성능이 좋음
- 세컨더리 인덱스는 보조 인덱스로, 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스

### MongoDB

- 도큐먼트를 만들면 자동으로 ObjectID가 형성되며, 해당 키가 기본키로 설정
- 세컨더리 키도 부가적으로 설정하여 기본키와 세컨더리키를 같이 쓰는 복합 인덱스 설정 가능

## 4.5.4 인덱스 최적화 기법

- 데이터베이스마다 조금씩 다르지만 기본적인 골조는 동일

### 1. 인덱스는 비용이다

- 인덱스는 두 번 탐색 강요
- 인덱스 리스트, 그 다음 컬렉션 순으로 탐색하기 때문이며, 관련 읽기 비용이 들게 됨
- 컬렉션 수정 시 인덱스도 수정
    
    → B-트리의 높이를 균형 있게 조절하는 비용도 들고, 데이터를 효율적으로 조회 가능하도록 분산시키는 비용도 듦
    
- 따라서 쿼리에 있는 필드에 인덱스를 무작정 다 설정하는 것은 답이 아니며, 컬레션에서 가져와야 하는 양이 많을수록 인덱스 사용은 비효율적

### 2. 항상 테스팅하라

- 인덱스 최적화 기법은 서비스 특징에 따라 변화
- 서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다르기 때문
- explain( ) 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간 최소화

### 3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다

- 보통 여러  필드를 기반으로 조회 시 복합 인덱스 생성
- 이 인덱스 생성 시 순서가 있고 생성 순서에 따라 인덱스 성능 변화
- 같음, 정렬, 다중 값, 카디널리티 순으로 생성
    1. 어떠한 값과 같음을 비교하는 ==이나 equal 이라는 쿼리가 있다면 제일 먼저 인덱스로 설정
    2. 정렬에 쓰는 필드라면 그 다음 인덱스로 설정
    3. 다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 > 이거나 < 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드라면 나중에 인덱스 설정
    4. 카디널리티는 유니크한 값의 정도를 의미하며, 높은 순서를 기반으로 인덱스를 생성

# 4.6 조인의 종류

---

- 조인(join)이란 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것
- MySQL에서는 JOIN이라는 쿼리로, MongoDB에서는 lookup이라는 쿼리로 이를 처리
- MongoDB 사용 시 lookup은 되도록 사용 X
    - 조인 연산(lookup)에 대해 관계형 데이터베이스보다 성능이 떨어짐
    - 따라서 여러 테이블을 조인하는 작업이 많을 경우 관계형 데이터 베이스 선호
- **조인의 종류**

![Untitled](WEEK08_%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8C%E1%85%A9%E1%86%BC%E1%84%85%E1%85%B2_%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3_%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%8B%E1%85%B4%E1%84%8C%E1%85%A9%E1%86%BC%E1%84%85%E1%85%B2_%E1%84%8C%E1%85%A9%E1%84%8B%204d7cb481048f49d7bd1807ebccafc514/Untitled%205.png)

1. **내부 조인(inner join)** : 왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기
2. **왼쪽 조인(left outer join)** : 왼쪽 테이블의 모든 행이 결과 테이블에 표기
3. **오른쪽 조인(right outer join)** : 오른쪽 테이블의 모든 행이 결과 테이블에 표기
4. **합집합 조인(full outer join)** : 두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기

![Untitled](WEEK08_%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8C%E1%85%A9%E1%86%BC%E1%84%85%E1%85%B2_%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3_%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%8B%E1%85%B4%E1%84%8C%E1%85%A9%E1%86%BC%E1%84%85%E1%85%B2_%E1%84%8C%E1%85%A9%E1%84%8B%204d7cb481048f49d7bd1807ebccafc514/Untitled%206.png)

### 4.6.1 내부 조인

- 두 테이블 간에 교집합

```sql
SELECT * FROM TableA A
INNER JOIN TableB B ON
A.key = B.key
```

### 4.6.2 왼쪽 조인

- 테이블 B의 일치하는 부분의 레코드와 함꼐 테이블 A를 기준으로 완전한 레코드 집합 생성
- 테이블 B에 일치하는 항목이 없으면 해당 값은 null 값

```sql
SELECT * FROM TableA A
LEFT JOIN TableB B ON
A.key = B.key
```

### 4.6.3 오른쪽 조인

- 테이블 A의 일치하는 부분의 레코드와 함꼐 테이블 B를 기준으로 완전한 레코드 집합 생성
- 테이블 A에 일치하는 항목이 없으면 해당 값은 null 값

```sql
SELECT * FROM TableA A
RIGHT JOIN TableB B ON
A.key = B.key
```

### 4.6.4 합집합 조인(완전 외부 조인)

- 양쪽 테이블에서 일치하는 레코드와 함께 테이블 A와 테이블 B의 모든 레코드 집합 생성
- 일치하는 항목이 없으면 누락된 쪽에 null 값이 포함되어 출력

```sql
SELECT * FROM TableA A
FULL OUTER JOIN TableB B ON
A.key = B.key
```

# 4.7 조인의 원리

---

## 4.7.1 중첩 루프 조인(NLJ, Nested Loop Join)

- 중첩 for 문과 같은 원리로 조건에 맞는 조인을 하는 방법
- 랜덤 접근에 대한 비용이 많이 증가하므로 대용량의 테이블에서는 사용 X

ex ) “t1, t2 테이블을 조인한다” 라고 했을 때 첫 번째 테이블에서 행을 한 번에 하나씩 읽고 그 다음 테이블에서도 행을 하나씩 읽어 조건에 맞는 레코드를 찾아 결괏값 반환

- 중첩 루프 조인에서 발전한 조인한 테이블을 작은 블록으로 나누어 블록 하나씩 조인하는 블록 중첩 루프 조인(BNL, Block Nested Loop) 방식도 존재

## 4.7.2 정렬 병합 조인

- 각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행하는 조인
- 조인 시 쓸 적절한 인덱스가 없고 대용량의 테이블들을 조인하고 조인 조건으로 <. > 등 범위 비교 연산자가 있을 시 사용

## 4.7.3 해시 조인

- 해시 테이블을 기반으로 조인
- 두개의 테이블을 조인한다고 했을 때 하나의 테이블이 메모리에 온전히 들어간다면 보통 중첩 루프 조인보다 더 효율적(메모리에 올릴 수 없을 정도로 크다면 디스크 사용 비용 발생)
- 동등(=) 조인에서만 사용 가능

### 빌드 단계

![Untitled](WEEK08_%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8C%E1%85%A9%E1%86%BC%E1%84%85%E1%85%B2_%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3_%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%8B%E1%85%B4%E1%84%8C%E1%85%A9%E1%86%BC%E1%84%85%E1%85%B2_%E1%84%8C%E1%85%A9%E1%84%8B%204d7cb481048f49d7bd1807ebccafc514/Untitled%207.png)

- 입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계
- persons와 countries라는 테이블 조인 시 둘 중 바이트가 더 작은 테이블을 기반으로 테이블 빌드
- 조인에 사용되는 필드가 테이블의 키로 사용(’countries, country_id’가 키로 사용)

### 프로브 단계

![Untitled](WEEK08_%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8C%E1%85%A9%E1%86%BC%E1%84%85%E1%85%B2_%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3_%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%8B%E1%85%B4%E1%84%8C%E1%85%A9%E1%86%BC%E1%84%85%E1%85%B2_%E1%84%8C%E1%85%A9%E1%84%8B%204d7cb481048f49d7bd1807ebccafc514/Untitled%208.png)

- 레코드 읽기를 시작하며, 각 레코드에서 ‘persons, country_id’에 일치하는 레코드를 찾아서 결괏값으로 반환
- 각 테이블은 한 번씩만 읽게 되어 중첩해서 두 개의 테이블을 읽는 중첩 루프 조인보다 성능 좋음
- 사용 가능한 메모리양은 시스템 변수 join_buffer_size에 의해 제어되며, 런타임 시에 조정