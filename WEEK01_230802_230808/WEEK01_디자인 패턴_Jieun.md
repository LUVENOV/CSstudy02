# 디자인 패턴

작성일시: 2023년 8월 5일 오후 2:27
최종 편집 일시: 2023년 8월 8일 오전 11:37

## 디자인 패턴

기존 환경에서 반복적으로 발생하는 어떤 문제를 어떻게 푸느냐에 대한 일종의 솔루션.

설계 시 발생한 문제들을 객체 상호 관계 등을 이용하여 해결하는 하나의 ‘규약’.

- **싱글톤 패턴 (Singleton)**
    
    : 하나의 `Class`에 오직 하나의 `instance.`
    
    - **Java 에서의 싱글톤 패턴 구현**
    
    `중첩 클래스`를 이용하여 만드는 방법이 가장 대중적
    
    ```java
    class Singleton {
    	private static class singleInstanceHolder {
        	private static final Singleton INSTANCE = new Singleton();
        }
        public static Singleton getInstance() {
        	return singleInstanceHolder.INSTANCE;
        }
    }
    
    public class HelloWorld {
    	public static void main(String[] args) {
        	Singleton a = Singleton.getInstance();
            Singleton b = Singleton.getInstance();
            System.out.println(a.hashCode());
            System.out.println(b.hashCode());
            if (a == b) {
            	System.out.println(true);
            }
        }
    }
    ```
    
    - **장점**
        
        인스턴스를 다른 모듈들이 공유 가능 ⇒ 인스턴스 생성 비용이 줄어든다.
        
    - **단점**
        - **상속**과 **다형성**을 해친다.
        - **의존성**이 높아진다.
            
            **의존성(=종속성) : 예를 들어, A가 B에 의존성이 있다면 B 변경 시, A도 변경되는 것이다.
            
        - **싱글톤 패턴**은 미리 생성된 하나의 인스턴스 기반으로 구현되어 각 테스트마다 **‘독립적인’ 인스턴스를 만들기 어렵다.**
            
            ** TDD(Test Driven Development)는 주로 단위 테스트를 실시하는데, 단위 테스트는 서로 독립적이어야 하고 어떤 순서로도 진행이 가능해야 한다. 
            
        - **의존성 주입**을 통해 해결 가능하다.
    
    - 💡**의존성 주입(DI)?**
        
        메인 모듈이 **‘간접적’으로 의존성을 주입**하도록 하여 모듈 간 결합을 강하게 한다.
        
        메인(상위)모듈은 하위 모듈에 대한 의존성이 떨어지는데, 이것을 **‘디커플링’**이라고 한다.
        
        장점 : **모듈 간 관계**들이 좀 더 **명확**해진다.
        
        단점 : 사실상 모듈이 더 분리되는 셈이라 **복잡성이 증가**된다.
        
    

---

- **팩토리 패턴 (factory)**
    
    : 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴.
    
    (객체 생성 공장을 떠올리면 이해가 쉽다.)
    
    - 상속 관계에 있는 두 클래스에서 `상위 클래스`가 중요한 뼈대를 결정하고,  `하위 클래스`에서 객체 생성에 관한 구체적 내용을 결정하는 패턴.
    - **객체 생성에 관여**한다.
    
    - **Java의 팩토리 패턴 구현**
        
        추후추가^^
        
    
    - **장점**
        - 상위 클래스의 **유연성**
        - **코드 리팩터링 유지 보수성** 증가 (객체 생성 로직이 따로 떼어져 있음.)
    - **단점**
        - 새로 생성할 객체가 늘어날 때마다, Factory 클래스에 추가해야 되기 때문에 클래스가 많아진다
    
    - 💡 **Enum 타입**
        - 상수의 집합을 정의할 때 사용되는 타입
        - 코드를 리팩터링할 때 해당 집합에 관한 로직 수정 시 이 부분만 수정하면 됨 : 큰 강점

---

- **전략 패턴(정책 패턴)**
    
    : 객체 행위를 바꿀 때, **‘캡슐화한 알고리즘(=전략)’**을 바꿔 상호 교체 가능하도록 한다.
  
    - **Java의 전략 패턴 구현**
        
        추후추가^^
    
    - **프로세스 진행에 관여**한다.
    
    (결제 방식의 전략을 바꾸어 2가지 방식을 구현하는 것을 떠올리면 이해가 쉽다.)
    
    - **장점**
        - 팩토리 패턴과 유사하게 공통 로직이 부모 클래스에 있지 않고 `Context` 라는 별도의 클래스에 존재하기 때문에 구현체들에 대한 **영향도**가 적음.
        - 쉽게 변하지 않는 **상위 인터페이스(클래스)에 의존**하기 때문에 **확장/삭제에 용이**하다.
    - **단점**
        - 로직이 늘어날 때 마다 구현체 클래스가 늘어난다.
        - 앱에 들어가는 모든 전략을 알고 있어야 해서, 한번 전략을 조립하면 변경하기가 힘들다.
    
    - 💡 **컨텍스트**
        
        프로그래밍에서의 컨텍스트 : 상황, 맥락, 문맥을 의미하며, 개발자가 어떠한 작업을 완료하는 데 필요한 모든 관련 정보
        
        ![Untitled](%E1%84%83%E1%85%B5%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%20f36c526cc5cd4650bfad02e1dc9803ab/Untitled.png)
        

---

- **옵저버 패턴 (Observer)**
    
    : 주체가 객체의 변화를 관찰하고 변경 시 옵저버에게 변화를 알려주는 패턴.

    - **Java에서의 구현**
        
        추후추가^^
    
    - **주체** : 객체의 상태 변화를 보고 있는 관찰자
    - **옵저버** : 이 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 '추가 변화 사항'이 생기는 객체들
    
    - **장점**
        - 변경 사항이 생겨도 무난히 처리할 수 있는 유연한 객체지향 시스템을 구축할 수 있다
        - **OCP (개방 폐쇄 원칙)**를 지킬 수 있다
        - 이벤트의 처리를 효율적으로 할 수 있다
    - **단점**
        - 알림이 가는 순서를 보장할 수 없다
        - 옵저버와 알림을 받는 Subject간의 관계가 잘 정의되지 않으면 원치 않는 동작이 발생할 확률이 높다
    

---

- **프록시 패턴과 프록시 서버**
    
    ### **프록시 패턴**
    
    : 대상 객체에 접근하기 전, 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 **인터페이스 역할**을 하는 디자인 패턴
    
    - 이를 통해 객체의 속성, 변환 등을 보안 / 데이터 검증 / 캐싱 / 로깅에 사용함
    - 프록시 객체로 쓰이기도 하지만, 프록시 서버로도 활용함
    
    - **장점**
        - 사이즈가 큰 객체가 로딩되기 전에도 프록시를 통해 참조를 할 수 있다.(전처리 및 후처리 사용 용이)
        - 특정 메서드에 대한 **보안**이 좋다. (B가 C에게 요청을 하여 A는 C가 무슨 일이 일어나는지 정확히 알기 힘들다는 점)
    - **단점**
        - **가독성**이 떨어진다. (A->B->C라는 구조로 누군가 거쳐가야 한다는 점 이런 경우가 많아지면 가독성이 떨어질 우려된다)
        
    
    ### 프록시 서버
    
    : 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용프로그램.
    
    ### 프록시 객체
    
    : 어떠한 대상의 기본적인 동작(속성 접근, 할당, 순회, 열거, 함수 호출 등)의 작업을 가로챌 수 있는 객체를 뜻함
    
    - 자바스크립트에서 프록시 객체는 **2개의 매개변수**를 가짐
    - 프록시 패턴이 녹아들어 있는 객체
    - **`target`** : 프록시할 대상
    - **`handler`** : 프록시 객체의 target 동작을 가로채서 정의할 동작들이 정해져 있는 함수
    

---

- **이터레이터 패턴**
    
    : 각기 다른 자료구조 구현체(array,linkedList,set)가 `iterator`라는 하나의 인터페이스를 통해 순회할 수 있도록 해주는 디자인 패턴
    
    - 컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체안에 들어있는 모든 항목에 접근할 수 있게 해 주는 방법을 제공
    
    - **장점**
        - 내부적인 구현 방법을 외부로 노출시키지 않으면서도 집합체에 있는 모든 항목에 일일이 접근할 수 있다
    - **단점**
        - 간단한 컬랙션인 경우, 이터레이터를 사용하는 것은 일부 특수 컬렉션의 요소를 직접 탐색하는 것 보다 덜 효율적일 수 있다

---

- **노출모듈 패턴**
    
    : `즉시 실행 함수`를 통해 `private`,`public`같은 **접근 제어자**를 만드는 패턴.
    
    💡`즉시 실행 함수` : 함수를 정의 하자마자 바로 호출하는 함수. 초기화 코드, 라이브러리 내 전역 변수의 충돌 방지 등에 사용한다
    

---

- **MVC 패턴**
    
    :  **Model, View, Controller**로 어플리케이션의 구성 요소를 세 가지 역할로 구분하고, 각 기능에 집중하는 디자인 패턴.
    
    - **장점**
        - 서로 분리되어 각각의 역할만 담당함으로써 **유지보수,확장성,유연성**이 증가됨
        - 중복 코딩이라는 문제점 또한 사라진다
    - **단점**
        - View와 Model 사이의 의존성이 높다 -> 어플리케이션이 커질수록 복잡해지고 유지 보수가 어렵다
    
    - **Model**
    - **View**
    - **Controller**

---

- **MVP 패턴**
    
    : MVC 패턴으로부터 파생되었으며 **MVC의 Controller 가 Presenter로 교체**된 패턴.
    
    - **장점**
        - View와 Model 사이에 **Presenter**라는 연결 부분을 두어 MVC 패턴의 단점인 의존성을 보완했다
            - MVC 패턴의 단점인 View와 Model사이의 의존성이 없다
    - **단점**
        - View와 Presenter사이는 1대1관계를 유지해야해서 의존성이 높고, 앱이 커질수록 이 의존성은 더 강해진다
    
    - **Presenter**
        - View에서 요청한 정보로 Model을 가공하여 View에 전달해 주는 부분. View와 Model을 붙여주는 접착제 역할을 한다(컨트롤러와 유사)
        - Presenter는 기존 MVC 패턴의 단점이었던 Model과 View 사이의 **높은 의존성**을 해소하기 위하여 등장

---

- **MVVM 패턴**
    
    : MVC의 C에 해당하는 **컨트롤러가 뷰 모델(View Model)**로 바뀐 패턴
    
    - MVVM은 View와 ViewModel사이의 관계가 **1대N**으로 되어있다
    
    - **장점**
        - View와 View Model 사이 양방향 데이터 바인딩을 지원한다
        - View와 Model 사이의 의존성이 없다. View와 View Model 사이의 의존성이 없다
        - UI를 별도의 코드 수정 없이 재사용할 수 있고 단위 테스팅하기 쉽다
    - **단점**
        - View Model의 설계가 어려움
    
    - **View Model(VM)**
        - View Model은 View를 더 추상화한 계층
        - View 상태를 유지 및 변화시키고, View에 대한 작업의 결과로 Model을 조작한다
        - View에서 발생되는 이벤트를 전달 하는데 도움이 되는 메서드, 명령, 또는 다른 속성들을 노출하는 역할을 한다
    

---
